/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "04.02.01"
}

/**
* User Door Unlock/Lock Notifications and Actions. Mirror of Multi User Lock Code Mgmt without the code programming, reuse existing lock programming
*
* Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
*
* Change Log:
* 2018-2-21 - (v04.02.01) Added support to arm SHM to Home when locking via keypad
* 2018-2-14 - (v04.02.00) Improved user configuration experience
* 2018-2-5 - (v04.01.00) Added support for locking/unlocking locks and opening/closing garage doors for lock/unlock actions. Added support to change modes for lock actions. Door sensor is now optional for relocking with timeout
* 2018-2-1 - (v04.00.04) Fix for ST breaking selection of Chime devices with mobile app 2.4.13
* 2018-1-21 - (v04.00.03) Added support for older device handlers to avoid a failure if users forgot to update the device handler
* 2018-1-17 - (v04.00.02) Added support for maxCodes, fix for ST Mobile app changes
* 2017-12-15 - (v04.00.01) Fix for manual unlock notifications not being sent
* 2017-12-4 - (v04.00.00) Added support for stock handler using lock codes, added support for manual lock and unlock actions
* 2017-11-14 - (v04.00.00) Added support for new ST stock DTH, improved code deletion confirmations
* 2017-11-8 - (v03.07.00) Added support for delayed lock actions and added support to arm SHM on lock and added icons and simplified the UI
* 2017-10-18 - (v03.06.00) Added check for disabling hardware autolock to use smartapp autorelock and autounlock features, fixed bug with notify modes, simplified UI
* 2017-5-31 - (v03.05.00) Improved deadbolt automatic unlocking for Schlage locks, added support for playing back on audio systems, added support for bluetooth
* 2017-5-29 - (v03.04.03) Bugfix for unlocking and locking without codes throwing an error
* 2017-5-26 - (v03.04.02) Due to ST phone changes, now separate multiple SMS numbers with a *
* 2017-4-19 - (v03.04.01) Patch for reporting Master Codes
* 2017-4-11 - (v03.04.00) Added ability to select Chimes for when doors are opened and closed, improved user interface/text, added user presence based notifications
* 2017-4-11 - (v03.03.01) Fixed grammar for messages
* 2017-1-25 - (v3.3.0) Added ability to run lock/unlock actions on when the specified users aren't present or not in specific modes, also less verbose messages unless detailed notifications are enabled while running lock and unlock actions
* 2017-1-12 - (v3.2.2) Added ability to report and run actions on unknown users (some locks don't report use code when unlocking via keypad) and master codes
* 2016-11-14 - Improved code update checks and now use ; instead of + for separating multiple SMS numbers
* 2016-10-30 - Fixed an issue with notifications not working and added code update notifications
* 2016-9-26 - Fix for broken ST phrases returning null data
* 2016-9-17 - Fixed issue with cannot change notify settings, highlight error messages, improved invalid date checks, code clean up
* 2016-9-16 - Fix for actions page not showing up when there are no routines defined on the hub
* 2016-9-16 - Patch for broken HREF pages in ST app 2.2.0
* 2016-9-13 - Bug fix when mode changes and no sensor is defined for door
* 2016-9-7 - Auto locks and open door notifications will engage if requried when mode changes
* 2016-9-2 - Added ability to specify modes of operations for auto door lock
* 2016-8-30 - Fixed bug with disable all push notifications, it should not disable text notifications and should only work when there is no contact address book
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-8-6 - Added support to auto relock door if the door hasn't been opened after specified timeout
* 2016-8-5 - Fix for autoRelock and openDoor notifications errors when using large timeout values
* 2016-7-25 - Added support for working with RFID cards
* 2016-7-22 - Added support for contact address book for customers who have this feature enabled
* 2016-7-19 - Updated code to use harmonized universal DH with type event instead of outsideLockEvent
* 2016-7-17 - Improvement to the unlocking and relocking logic
* 2016-7-17 - Workaround for platform calling installed and updated when installing the SmartApp
* 2016-7-17 - Put in a check to not enable automatic unlock if autolock in the door is enabled
* 2016-7-14 - Improved notifications
* 2016-7-13 - Added support for tamper events and when using user codes to lock the door from the keypad
* 2016-7-10 - Added support for running routine when the door is locked using external keypad lock button
* 2016-7-5 - Added support for notifications if door is left open, added support for delayed relock for multiple door and various minor UI improvements
* 2016-7-5 - Added client version on main page
* 2016-4-8 - Added support for notification modes for unlocking (and improved UI)
* 2016-4-8 - Bugfix for jammed and manual lock notifications not coming
* 2016-2-20 - Added slot notification for unknown users 
* 2016-2-7 - Revamped from scratch
*
*/
definition(
    name: "User Unlock/Lock Door Notifications and Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Execute actions when users unlock/lock doors",
    category: "Safety & Security",
    iconUrl: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active.png",
    iconX2Url: "https://s3.amazonaws.com/smartapp-icons/Solution/doors-locks-active@2x.png"
)

preferences {
    page(name: "setupApp")
    page(name: "usersPage")
    page(name: "unlockLockActionsPage")
    page(name: "unlockKeypadActionsPage")
    page(name: "unlockManualActionsPage")
    page(name: "lockKeypadActionsPage")
    page(name: "lockManualActionsPage")
    page(name: "openCloseDoorPage")
    page(name: "userConfigPage")
}

def setupApp() {
    log.trace "$settings"

    dynamicPage(name: "setupApp", title: "User Door Unlock/Lock Notifications and Actions v${clientVersion()}", install: true, uninstall: true) {    
        section("Select Lock(s)") {
            input "locks","capability.lock", title: "Lock(s)", multiple: true, submitOnChange: true, image: "http://www.rboyapps.com/images/HandleLock.png"
        }

        section("How many users do you want to monitor?") {
            def maxCodes = 0
            for (lock in locks) {
                Integer lockMax = lock.hasAttribute("maxCodes") ? lock.currentValue("maxCodes") : 0
                log.trace "$lock has max users: $lockMax"
                maxCodes = maxCodes ? (lockMax ? Math.max(lockMax, maxCodes) as Integer : maxCodes) : (lockMax ?: 0) // Take the highest amongst all selected locks
            }
            input name: "maxUserNames", title: "Number of users${maxCodes ? " (1 to ${maxCodes})" : ""}", type: "number", required: true, multiple: false, image: "http://www.rboyapps.com/images/Users.png", range: "1..${maxCodes ?: 999}"
            href(name: "users", title: "Configure users", page: "usersPage", description: "User names and custom actions", required: false, image: "http://www.rboyapps.com/images/User.png")
        }

        section("General Settings") {
            // Unlock actions for all users (global)
            def hrefParams = [
                user: null, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Lock/unlock actions", page: "unlockLockActionsPage", description: "Define actions and notitications when users lock/unlock doors", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
            href(name: "openCloseDoor", title: "Door open/close actions", page: "openCloseDoorPage", description: "Define actions and notitications when users open/close doors", required: false, image: "http://www.rboyapps.com/images/DoorOpenClose.png")

            input("recipients", "contact", title: "Send notifications to", multiple: true, required: false, image: "http://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*+448747654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
                paragraph "Enable the below option if you DON'T want push notifications on your SmartThings phone app."
                input name: "disableAllNotify", title: "Disable all push notifications", type: "bool", defaultValue: "false", required: true
            }
            input "audioDevices", "capability.audioNotification", title: "Play notifications on these devices", required: false, multiple: true, image: "http://www.rboyapps.com/images/Horn.png"
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }

        section("Advanced Options (optional)", hideable: true, hidden: true) {
            paragraph "Enable this to get additional detailed notifications about lock/unlock/open/close actions being executed"
            input name: "detailedNotifications", title: "Get detailed notifications", type: "bool", defaultValue: "false", required: false
        }
    }
}

def openCloseDoorPage() {
    dynamicPage(name:"openCloseDoorPage", title: "Select door open/close sensor for each door and configure the automatic unlock, relock and notifications of the door", uninstall: false, install: false) {
        section {
            for (lock in locks) {
                def priorRelockDoor = settings."relockDoor${lock}"
                def priorRelockImmediate = settings."relockImmediate${lock}"
                def priorRelockAfter = settings."relockAfter${lock}"
                def priorRetractDeadbolt = settings."retractDeadbolt${lock}"
                def priorNotifyOpen = settings."openNotify${lock}"
                def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
                def priorOpenNotifyModes = settings."openNotifyModes${lock}"
                def priorRelockDoorModes = settings."relockDoorModes${lock}"
                def priorNotifyBeep = settings."openNotifyBeep${lock}"

                paragraph "\r\n"
                paragraph title: "Configure ${lock}", required: true, ""
                if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep) {
                    input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor", required: ( priorRelockImmediate || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep ? true : false) // required for deadbolt, immediate relock or notifications
                }

                // Sanity check do not offer AutoLock is hardware autoLock is engaged
                if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                    paragraph title: "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features", required: true, ""
                } else {
                    input name: "relockDoor${lock}", type: "bool", title: "Relock door automatically after closing", defaultValue: priorRelockDoor, required: false, submitOnChange: true
                    if (priorRelockDoor) {
                        input name: "relockImmediate${lock}", type: "bool", title: "Relock immediately", defaultValue: priorRelockImmediate, required: false, submitOnChange: true
                        if (!priorRelockImmediate) {
                            input name: "relockAfter${lock}", type: "number", title: "Relock after (minutes)", defaultValue: priorRelockAfter, required: true                   
                        }
                        input name: "relockDoorModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                    }
                    if (priorRetractDeadbolt) {
                        paragraph "NOTE: Make sure the AutoLock feature on the lock is disabled to avoid an infinite locking/unlocking loop.", required: false, submitOnChange: true
                    }
                    input name: "retractDeadbolt${lock}", type: "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, description: "This retracts the deadbolt if it extends while the door is still open", required: false, submitOnChange: true
                }

                input "openNotifyBeep${lock}", "capability.tone", title: "Ring chime when door is opened", multiple: true, required: false, submitOnChange: true
                input name: "openNotify${lock}", type: "bool", title: "Notify if door has been left open", defaultValue: priorNotifyOpen, required: false, submitOnChange: true
                if (priorNotifyOpen) {
                    input name: "openNotifyTimeout${lock}", type: "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"
                }
                if (priorNotifyOpen || priorNotifyBeep) {
                    input name: "openNotifyModes${lock}", type: "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
                }
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Lock/Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: "Setup lock/unlock actions for each door" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        def showActions = true
        if (!phrases) {
            log.warn "No Routines found!!!"
        }
        section {
            if (user) { // User specific override options
                paragraph "Enabling custom user actions and notifications will override over the general actions defined on the first page"
                input "userOverrideUnlockActions${user}", "bool", title: "Define custom actions for $name", required: true,  submitOnChange: true
                if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    showActions = false
                }
            }
            if  (showActions && locks?.size() > 1) {
                input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
            }
        }
        if (showActions) { // Do we need to show actions?
            if (settings."individualDoorActions${user}") {
                for (lock in locks) {
                    section ("$lock", hideable: false) {
                        def hrefParams = [
                            user: user,
                            lock: lock as String,
                            passed: true 
                        ]
                        href(name: "unlockKeypadActions${lock}", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                        href(name: "lockKeypadActions${lock}", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                        if (!user) {
                            href(name: "unlockManualActions${lock}", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                            href(name: "lockManualActions${lock}", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                        }
                    }
                }
            } else {
                section("", hideable: false) {
                    def hrefParams = [
                        user: user,
                        lock: "",
                        passed: true 
                    ]
                    href(name: "unlockKeypadActions", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadUnlocked.png")
                    href(name: "lockKeypadActions", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/KeypadLocked.png")
                    if (!user) {
                        href(name: "unlockManualActions", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualUnlocked.png")
                        href(name: "lockManualActions", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "http://www.rboyapps.com/images/ManualLocked.png")
                    }
                }
            }
        }
    }
}

def unlockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Unlock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockKeypadActionsPage", title: "Setup keypad unlock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhrase${lock}${user}"
            def priorHomeMode = settings."homeMode${lock}${user}"

            paragraph "Run these actions when a user successfully unlocks the door using a code"
            input "homePhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeDisarm${lock}${user}", "bool", title: "Disarm Smart Home Monitor", required: false
            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocks${lock}${user}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarage${lock}${user}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true	    

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
        }
    }
}

def unlockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Manual Unlock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockManualActionsPage", title: "Setup manual unlock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Unlock Actions${lock ? " for $lock" : ""}") {
            def priorHomePhrase = settings."homePhraseManual${lock}"
            def priorHomeMode = settings."homeModeManual${lock}"
            def priorManualNotify = settings."manualNotify${lock}"

            paragraph "Run these actions when a user unlocks the door manually"
            input "homePhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeDisarmManual${lock}", "bool", title: "Disarm Smart Home Monitor", required: false
            input "turnOnSwitchesAfterSunsetManual${lock}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocksManual${lock}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarageManual${lock}","capability.garageDoorControl", title: "Open garage door(s)", required: false, multiple: true	    

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Unlock Notification Options"
            input "manualNotify${lock}", "bool", title: "Notify on manual unlock", required: false, submitOnChange: true
            if (priorManualNotify) {
                input "manualNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def lockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Lock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockKeypadActionsPage", title: "Setup keypad lock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Keypad Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
            def priorHomeMode = settings."externalLockMode${lock}${user}"

            paragraph "Some locks can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign actions to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
            input "externalLockPhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeArm${lock}${user}", "bool", title: "Arm Smart Home Monitor to Away", required: false, submitOnChange: true
            if (settings."homeArm${lock}${user}") {
                input "homeArmStay${lock}${user}", "bool", title: "...arm to Home instead of Away", required: false
            }
            input "externalLockTurnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocks${lock}${user}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarage${lock}${user}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActions${lock}${user}", "bool", title: "Delay running lock actions", required: false, submitOnChange: true
            if (settings."delayLockActions${lock}${user}") {
                input name: "delayLockActionsTime${lock}${user}", type: "number", title: "...by (minutes)", defaultValue: settings."delayLockActionsTime${lock}${user}", required: true, range: "1..*"
            }

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            if (!user) { // Users will use the user notify option
                paragraph "Lock Notification Options"
                input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", required: false, submitOnChange: true
                if (settings."externalLockNotify${lock}") {
                    input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                }
            }

            if (!user) { // Users will use the user notify option
                input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck", required: false
            }
        }
    }
}

def lockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Manual Lock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockManualActionsPage", title: "Setup manual lock actions for doors", uninstall: false, install: false) {
        def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
        if (!phrases) { // This should not happen, it should be taken care of in parent page
            log.warn "No Routines found!!!"
        }

        section ("Door Manual Lock Actions${lock ? " for $lock" : ""}") {
            def priorLockPhrase = settings."externalLockPhraseManual${lock}"
            def priorHomeMode = settings."externalLockModeManual${lock}"

            input "externalLockPhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "homeArmManual${lock}", "bool", title: "Arm Smart Home Monitor to Home", required: false
            input "externalLockTurnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocksManual${lock}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarageManual${lock}","capability.garageDoorControl", title: "Close garage door(s)", required: false, multiple: true
            input "delayLockActionsManual${lock}", "bool", title: "Delay running lock actions", required: false, submitOnChange: true
            if (settings."delayLockActionsManual${lock}") {
                input name: "delayLockActionsTimeManual${lock}", type: "number", title: "...by (minutes)", defaultValue: settings."delayLockActionsTimeManual${lock}", required: true, range: "1..*"
            }

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Lock Notification Options"
            input "lockNotify${lock}", "bool", title: "Notify on manual/auto lock", required: false, submitOnChange: true
            if (settings."lockNotify${lock}") {
                input "lockNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def usersPage() {
    dynamicPage(name:"usersPage", title: "User Names, Actions and Notification Setup", uninstall: false, install: false) {

        if (!settings.maxUserNames) {
            section("Invalid number of users") {
                paragraph title: "First configure the number of users on the previous page", required: true, ""
            }
        }

        section() {
            for (int i = 1; i <= settings.maxUserNames; i++) {
                def priorName = settings."userNames${i}"
                def priorNotify = settings."userNotify${i}"
                def priorNotifyModes = settings."userNotifyModes${i}"
                //log.trace "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

                // Params for user
                def hrefParams = [
                    user: i as String,
                    passed: true 
                ]
                href(name: "userConfig${i}", params: hrefParams, title: "Slot ${i} - ${priorName ?: "< blank >"}", page: "userConfigPage", description: "", required: false, image: ("http://www.rboyapps.com/images/User.png"))
            }
        }
    }
}

def userConfigPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user:$user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user:$user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }

    def name = user ? settings."userNames${user}" : ""
    def i = user as Integer

    log.trace "User Codes Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"userConfigPage", title: "User Slot #${i}", uninstall: false, install: false) {
        section() {
            def priorName = settings."userNames${i}"
            def priorNotify = settings."userNotify${i}"
            def priorNotifyModes = settings."userNotifyModes${i}"
            //log.trace "Initial $i Name: $priorName, Notify: $priorNotify, NotifyModes: $priorNotifyModes"

            // User and code details/types
            input "userNames${i}", "text", description: "Tap to set", title: "Name", multiple: false, required: false, submitOnChange: false, image: "http://www.rboyapps.com/images/User.png"
            input "userNotify${i}", "bool", title: "Notify on use", defaultValue: true, required: false, submitOnChange: true, image: "http://www.rboyapps.com/images/Notifications.png"
            input "userNotifyModes${i}", "mode", title: "...only when in this mode(s)", description: "Notify only when in any of these modes", required: false, multiple: true
            input "userXNotifyPresence${i}", "capability.presenceSensor", title: "...and when these people are not present", description: "and none of these people are present", required: false, multiple: true

            // Unlock actions for each user
            def hrefParams = [
                user: i as String, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Custom actions for lock/unlock", page: "unlockLockActionsPage", description: settings."userOverrideUnlockActions${user}" ? "Configured" : "", required: false, image: "http://www.rboyapps.com/images/LockUnlock.png")
        } 
    } 
}

def installed()
{
    log.debug "Install Settings: $settings"
    appTouch()
}

def updated()
{
    log.debug "Update Settings: $settings"
    appTouch()
}

def appTouch() {
    unschedule() // clear all pending updates
    unsubscribe()

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
    
    // subscribe to random events to kick start timers again due to buggy platform killing the timers after a while and presence/mode events to update code states
    subscribe(location, "mode", changeHandler)
    subscribe(location, "position", changeHandler)
    subscribe(location, "sunset", changeHandler)
    subscribe(location, "sunrise", changeHandler)
    subscribe(location, "routineExecuted", changeHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
            log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
            subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on lock $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }

    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt?.name}, value: ${evt?.value}, device: ${evt?.device}"
    
    if (evt?.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            if (sensor) {
                log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
                def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
                sensorHandler(sensorEvt)
            }
        }
    }
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.trace "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
            } else {
                if (settings."relockImmediate${lock}") {
                    log.debug "Relocking ${lock} immediately in 3 seconds"
                    def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                        //log.trace "Adding ${lock.id} to the list of immediate locks"
                        immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                        atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                    }
                    immediateLockDoor() // Lock it right away
                } else if (settings."relockAfter${lock}") {
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    //log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.error "Invalid configuration, no relock timeout defined"
                }
            }
        }
    } else { // Door was opened
        // Chime bell
        if (settings."openNotifyBeep${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Door ${sensor} was opened, chiming bell ${settings."openNotifyBeep${lock}"}"
                settings."openNotifyBeep${lock}".beep() // Beep
            } else {
                log.trace "${lock} chiming not set for Mode ${location.mode}"
            }
        }

        // Notify user
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending door unlocks ${unLocksIDs}"

    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        //log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending immediate door locks ${immediateLocksIDs}"

    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        //log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (!lockSensor) { // If we don't have a sensor then just lock on schedule
                log.info "No sensor found on ${lock} when closed, locking the door"
                lock.lock() // lock it
                //log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                //log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else if (lockSensor.latestValue("contact") == "closed") {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                lock.lock() // lock it
                //log.trace "Removing ${lockid} from the list of pending relocks"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
                //log.trace "Checking for any pending relocks in 3 seconds"
                startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                return // We're done here
            } else {
                log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                startTimer(60, reLockDoor) // Check back again in some time
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.trace "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                //log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user and checking again after ${settings."openNotifyTimeout${lock}"} minutes"
                def msg = "$lock has been open for ${settings."openNotifyTimeout${lock}"} minutes"

                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
                sendNotifications(msg) // Do it in the end to avoid a timeout
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

// Lock event handler
def lockHandler(evt) {
    def data = null
    def lock = evt.device
    
    log.trace "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    def evtMap = [name:evt.name, value:evt.value, displayName:evt.displayName, descriptionText:evt.descriptionText, data:evt.data, lockId: evt.device.id]

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            processUnlockEvent(evtMap)
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            processLockEvent(evtMap)
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Too many invalid user codes detected on lock $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on lock $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}

def processUnlockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

	log.trace "Processing $lock unlock event: $evt"

    // Check if we have delayed relock is enabled, if so then start the timer now just incase the user never opens the door (reLockDoor will take care of sensor if present, immediate relock should never happen without a sensor)
    if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
        if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
            log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
        } else {
            log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
            def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            //log.trace "Adding ${lock.id} to the list of relocks"
            reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
            atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
            reLockDoor() // Call relock door it'll take of delaying the lock as required
        }
    } else {
        log.trace "Relock conditions not met, not scheduling relock"
    }

    if (evt.data) { // Was it unlocked using a code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via rfid"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    if ((data?.usedCode == null) && !(["keypad", "rfid"].any { lockMode?.contains(it) })) { // No extended data, must be a manual/auto/keyed unlock, NOTE: some locks don't send keypad user codes
        log.trace "$evt.displayName was unlocked manually. Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            def msg = "$evt.displayName was unlocked $lockMode"

            if (settings."homeDisarmManual${lockStr}") {
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }

            if (settings."homeModeManual${lockStr}") {
                log.info "Changing mode to ${settings."homeModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."homeModeManual${lockStr}"}) {
                    setLocationMode(settings."homeModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeModeManual${lockStr}"}" : ""
            }

            if (settings."homePhraseManual${lockStr}") {
                log.info "Running unlock Phrase ${settings."homePhraseManual${lockStr}"}"
                location.helloHome.execute(settings."homePhraseManual${lockStr}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhraseManual${lockStr}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunsetManual${lockStr}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunsetManual${lockStr}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"}" : ""
                }
            }

            if (settings."turnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitchesManual${lockStr}"}"
                settings."turnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."turnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitchesManual${lockStr}"}"
                settings."turnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."unlockLocksManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocksManual${lockStr}"}"
                settings."unlockLocksManual${lockStr}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocksManual${lockStr}"}" : ""
            }

            if (settings."openGarageManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarageManual${lockStr}"}"
                settings."openGarageManual${lockStr}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarageManual${lockStr}"}" : ""
            }	    

            if (settings."manualNotify${lockStr}" && (settings."manualNotifyModes${lockStr}" ? settings."manualNotifyModes${lockStr}".find{it == location.mode} : true)) {
                sendNotifications(msg)
            }
        }
    } else { // KEYPAD / RFID UNLOCK
        Integer i = data.usedCode as Integer
        def name = settings."userNames${i}"
        def notify = settings."userNotify${i}"
        def notifyModes = settings."userNotifyModes${i}"
        def notifyXPresence = settings."userXNotifyPresence${i}"

        log.trace "Lock $evt.displayName unlocked by $name, notify $notify, notify modes $notifyModes, notify NOT present $notifyXPresence, Source type: $lockMode"

        def msg = ""

        if (i == 0) {
            name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
            notify = true // always inform about master users
        }

        if (name == null) { // will handle usedCode null errors
            notify = true // always inform about unknown users
            msg = "$evt.displayName was unlocked by Unknown User from slot $i $lockMode"
        } else {
            msg = "$evt.displayName was unlocked by $name $lockMode"
        }

        // Check if we have user override unlock actions defined
        def user = ""
        if (settings."userOverrideUnlockActions${i as String}") {
            log.trace "Found per user unlock actions"
            user = i as String
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            if (settings."homeDisarm${lockStr}${user}") {
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }

            if (settings."homeMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."homeMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."homeMode${lockStr}${user}"}) {
                    setLocationMode(settings."homeMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeMode${lockStr}${user}"}" : ""
            }

            if (settings."homePhrase${lockStr}${user}") {
                log.info "Running unlock Phrase ${settings."homePhrase${lockStr}${user}"}"
                location.helloHome.execute(settings."homePhrase${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhrase${lockStr}${user}"}" : ""
            }

            if (settings."turnOnSwitchesAfterSunset${lockStr}${user}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunset${lockStr}${user}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"}" : ""
                }
            }

            if (settings."turnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lockStr}${user}"}"
                settings."turnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."turnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lockStr}${user}"}"
                settings."turnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."unlockLocks${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocks${lockStr}${user}"}"
                settings."unlockLocks${lockStr}${user}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocks${lockStr}${user}"}" : ""
            }

            if (settings."openGarage${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarage${lockStr}${user}"}"
                settings."openGarage${lockStr}${user}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarage${lockStr}${user}"}" : ""
            }	    
        }

        // Send notifications
        if (notify && (
            (notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            (notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
        )) {
            sendNotifications(msg)
        }
    }
}

def processLockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

    log.trace "Processing $lock lock event: $evt"

    def msgs = [] // Message to send

    if (evt.data) { // Was it locked using a user code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar and additional lock types mapping
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via rfid"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    evt.lockMode = lockMode // Save the lockMode calculated
    evt.data = data // Update the data to be passed
    def user = (data?.usedCode as String) ?: "" // get the user if present

    log.trace "$lock locked by user $user $lockMode"

    // Check if we have individual actions for each lock
    def lockStr = ""
    if (settings."individualDoorActions${user}") {
        lockStr = lock as String
    } else {
        lockStr = ""
    }

    if ((["keypad", "rfid"].any { lockMode?.contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActions${lockStr}${user}") {
            log.debug "Delaying keypad lock actions by ${settings."delayLockActionsTime${lockStr}${user}"} minutes"
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTime${lockStr}${user}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    } else { // MANUAL LOCK
        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsManual${lockStr}") {
            log.debug "Delaying manual lock actions by ${settings."delayLockActionsTimeManual${lockStr}"} minutes"
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTimeManual${lockStr}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    }

    // Check if we need to retract a deadbolt lock it was locked while the door was still open
    if (settings."retractDeadbolt${lock}") {
        def sensor = settings."sensor${lock}"
        if (sensor.latestValue("contact") == "open") {
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                def msg = "Unlock on door open will NOT work while the AutoLock feature is enabled on $lock lock to avoid an infinite loop to locking/unlocking"
                log.warn msg
                msgs << msg
            } else {
                log.debug "$lock was locked while the door was still open, unlocking it in 10 seconds"
                def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                    //log.trace "Adding ${lock.id} to the list of unlocks"
                    unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                }
                startTimer(10, unLockDoor) // Schedule the unlock in 10 seconds since the door may have just locked and avoid Z-Wave conflict and some locks like Schlage deadbolt have timing limitations which cause a busy conflict if done too soon
            }
        } else {
            log.trace "$lock was locked while the door was closed, we're good"
        }
    }

    // Last thing to do because it can timeout
    for (msg in msgs) {
        sendNotifications(msg)
    }
}

def processLockActions(evt) {
    def data = evt.data
    def lock = locks.find { it.id == evt.lockId }
    def msgs = [] // Message to send
    def lockMode = evt.lockMode

    log.trace "Processing $lock lock actions: $evt"

    if ((["keypad", "rfid"].any { lockMode?.contains(it) }) || (data?.usedCode != null)) { // LOCKED VIA KEYPAD/RFID
        def user = ""
        def name, notify, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions

        if ((data instanceof org.codehaus.groovy.grails.web.json.JSONObject ? !data?.isNull("usedCode") : (data?.usedCode != null)) && (data?.usedCode >= 0)) { // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442
            Integer i = data.usedCode as Integer

            if (i == 0) {
                name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                notify = true // always inform about master users
            } else {
                user = i as String
                name = settings."userNames${i}"
                notify = settings."userNotify${i}"
                notifyModes = settings."userNotifyModes${i}"
                notifyXPresence = settings."userXNotifyPresence${i}"
                userOverrideActions = settings."userOverrideUnlockActions${i}"

                // Check if we have user override lock actions defined
                if (!settings."userOverrideUnlockActions${i}") {
                    log.trace "No user $name specific lock action found, falling back to global actions"
                    user = "" // We don't have a user specific action defined, fall back to global actions
                }
            }
        } else {
            log.trace "No usercode found in extended data for external user lock"
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        extLockNotify = settings."externalLockNotify${lockStr}"
        extLockNotifyModes = settings."externalLockNotifyModes${lockStr}"

        log.trace "Lock $evt.displayName locked by $name, user notify $notify, user notify modes $notifyModes, notify NOT present $notifyXPresence, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, Source type: $lockMode"

        def msg = "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode" // Default message to send

        if (settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            if (settings."homeArm${lockStr}${user}") {
                if ("homeArmStay${lockStr}${user}") {
                    log.info "Arming Smart Home Monitor to Home"
                    sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                    msg += detailedNotifications ? ", Arming Smart Home Monitor to Home" : ""
                } else {
                    log.info "Arming Smart Home Monitor to Away"
                    sendLocationEvent(name: "alarmSystemStatus", value: "away")
                    msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                }
            }
	    
            if (settings."externalLockMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."externalLockMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."externalLockMode${lockStr}${user}"}) {
                    setLocationMode(settings."externalLockMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockMode${lockStr}${user}"}" : ""
            }	    

            if (settings."externalLockPhrase${lockStr}${user}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhrase${lockStr}${user}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhrase${lockStr}${user}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhrase${lockStr}${user}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}"}"
                settings."externalLockTurnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."externalLockTurnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}"}"
                settings."externalLockTurnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."lockLocks${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocks${lockStr}${user}"}"
                settings."lockLocks${lockStr}${user}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocks${lockStr}${user}"}" : ""
            }

            if (settings."closeGarage${lockStr}${user}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarage${lockStr}${user}"}"
                settings."closeGarage${lockStr}${user}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarage${lockStr}${user}"}" : ""
            }	    
        }

        // Send a notification if required (message would be updated)
        if ((user && notify && (
            (notifyModes ? notifyModes.find{it == location.mode} : true) &&
            (notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
        )) ||
            (extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
            msgs << msg
        }
    } else { // MANUAL LOCK
        log.trace "Lock $evt.displayName locked manually, Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        def msg = "$evt.displayName was locked $lockMode" // Default message to send

        if (settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            if (settings."homeArmManual${lockStr}") {
                log.info "Arming Smart Home Monitor to Home/Stay"
                sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                msg += detailedNotifications ? ", Arming Smart Home Monitor to Home" : ""
            }
	    
            if (settings."externalLockModeManual${lockStr}") {
                log.info "Changing mode to ${settings."externalLockModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."externalLockModeManual${lockStr}"}) {
                    setLocationMode(settings."externalLockModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockModeManual${lockStr}"}" : ""
            }	    

            if (settings."externalLockPhraseManual${lockStr}") {
                log.info "Running $lock specific locked Phrase ${settings."externalLockPhraseManual${lockStr}"} for ${name ?: "external lock"}"
                location.helloHome.execute(settings."externalLockPhraseManual${lockStr}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhraseManual${lockStr}"}" : ""
            } else {
                log.trace "No individual routine configured to run when locked $lockMode for $lock"
            }

            if (settings."externalLockTurnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}"
                settings."externalLockTurnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."externalLockTurnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}"
                settings."externalLockTurnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}" : ""
            }
	    
            if (settings."lockLocksManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocksManual${lockStr}"}"
                settings."lockLocksManual${lockStr}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocksManual${lockStr}"}" : ""
            }

            if (settings."closeGarageManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarageManual${lockStr}"}"
                settings."closeGarageManual${lockStr}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarageManual${lockStr}"}" : ""
            }	    
        }

        // Send notitications for manual and electronic locking only, keypad is handled above with lock actions
        if (settings."lockNotify${lockStr}" && (!(["keypad", "rfid"].any { lockMode?.contains(it) })) && (settings."lockNotifyModes${lockStr}" ? settings."lockNotifyModes${lockStr}".find{it == location.mode} : true)) {
            msgs << msg
        }
    }
    
    // Check if we are asked to send the notifications or return them back
    if (evt.sendNotifications) {
        // Last thing to do because it can timeout
        for (msg1 in msgs) {
            sendNotifications(msg1)
        }
    } else {
        return msgs
    }
}

def startTimer(seconds, function, dataMap = null) {
    log.trace "Scheduled to run $function in $seconds seconds"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    if (dataMap) {
        runIn(seconds, function, [overwrite: true, data: dataMap]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    } else {
        runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private void sendNotifications(message) {
	if (!message) {
		return
    }
    
	if (location.contactBookEnabled) {
        sendNotificationToContacts(message, recipients)
    } else {
        if (!disableAllNotify) {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (sms) {
            sendText(sms, message)
        }
    }
    if (audioDevices) {
        audioDevices*.playText(message)
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "User Unlock Lock Door Notifications and Actions"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = locks?.findAll { it.hasAttribute("codeVersion") }
                for (device in devices) {
                    if (device) {
                        def deviceName = device?.currentValue("dhName")
                        def deviceVersion = ret.data?."$deviceName"
                        if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                            def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                            log.info msg
                            if (!disableUpdateNotifications) {
                                sendPush(msg)
                            }
                        } else {
                            log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE