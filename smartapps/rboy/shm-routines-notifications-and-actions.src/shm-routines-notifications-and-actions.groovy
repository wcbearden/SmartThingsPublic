/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "01.00.00"
}

/**
* Notify if any doors/windows/switches/lock/values/shades are open or closed on when the SHM state changes and take actions and run routines
*
* Copyright RBoy Apps, redistribution of code is not allowed without permission
*
* 2018-3-1 - (v01.00.00) Initial release
*
*/
definition(
    name: "SHM Routines, Notifications and Actions",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Run a set of routine checks and actions when SHM changes state. Notify if there are any Door/Window/Switch/Lock/Valve/Shades that are open/unlocked and closes/locks them when the SHM state changes",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX2Url: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX3Url: "http://smartthings.rboyapps.com/images/OpenDoor.png")

preferences {
    page(name: "mainPage")
    page(name: "modeDoorMonitorPage")
}

private getShmModes() { ["away":"Away", "stay":"Home", "off":"Disarmed"] }

private getCheckingDescription(mode) {
    def description = ""

    def devices = [
        			settings."doors${mode}",
        			settings."doorsflip${mode}",
        			settings."garagedoors${mode}",
                   	settings."garagedoorsflip${mode}",
        			settings."locks${mode}",
               	    settings."locksflip${mode}",
               	    settings."switches${mode}",
               	    settings."switchesflip${mode}",
               	    settings."shades${mode}",
               	    settings."shadesflip${mode}",
                   	settings."valves${mode}",
        			settings."valvesflip${mode}",
    			]
    
    for (device in devices) {                   
        description += device ? (description ? "\n  " : "") + device?.join("\n  ") : ""
    }

    if (!description) { // Nothing selected
        description = "No devices selected"
    } else {
        description = "Checking:\n  " + description // Add the header
    }

    return description
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "SHM Routines, Notifications and Actions v${clientVersion()}", install: true, uninstall: true) {
        section() {
            paragraph "Click on each SHM state below to configure notifications, routines and actions for doors/windows/garages/switches/locks/valves/shades for the respective SHM state"
        }

        shmModes.each { mode, name ->
            section {
                // Unlock actions for each mode
                def hrefParams = [
                    mode: mode as String,
                    name: name as String,
                    passed: true 
                ]
                log.trace "SHM State $mode, Name $name"
                href(name: "modeDoorMonitor", params: hrefParams, title: "When switching to state ${name}", page: "modeDoorMonitorPage", description: getCheckingDescription(mode), required: false)
            }
        }

        section("General Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                input name: "notify", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
            }
        }

        section() {
            label title: "Assign a name for this SmartApp (optional)", required: false
            input name: "disableUpdateNotifications", title: "Don't check for new versions of the app", type: "bool", required: false
        }
    }
}

def modeDoorMonitorPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def mode = ""
    def name = ""
    // Get mode from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.mode) {
        mode = params.mode
        name = params.name
        log.trace "Passed from main page, using params lookup for mode $mode, name $name"
    } else if (atomicState.params) {
        mode = atomicState.params.mode ?: ""
        name = atomicState.params.name ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for mode $mode, name $name"
    } else {
        log.error "Invalid params, no mode found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Mode Door Monitor, mode:$mode, name $name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"modeDoorMonitorPage", title: "Configure notification options when changing to state " + (name ?: ""), uninstall: false, install: false) {
        section("Choose Door(s) and Window(s)") {
            paragraph "Notify if any of these doors or windows are left open/closed when SHM changes to $name"
            input "doors${mode}", "capability.contactSensor", title: "Check for Open doors/windows", required: false, multiple:true
            input "doorsflip${mode}", "capability.contactSensor", title: "Check for Closed doors/windows", required: false, multiple:true
        }

        section("Choose Garage Door(s)") {
            paragraph "Notify if any of these selected garage doors are left open/closed when SHM changes to $name"
            input "garagedoors${mode}", "capability.garageDoorControl", title: "Check for Open garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoors${mode}") {
                input "garagedoorsoff${mode}", "bool", title: "Close them?", required: false
            }
            input "garagedoorsflip${mode}", "capability.garageDoorControl", title: "Check for Closed garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoorsflip${mode}") {
                input "garagedoorsopen${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Lock(s)") {
            paragraph "Notify if any of these selected locks are Unlocked/Locked when SHM changes to $name"
            input "locks${mode}", "capability.lock", title: "Check for Unlocked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locks${mode}") {
                input "locksoff${mode}", "bool", title: "Lock them?", required: false
            }
            input "locksflip${mode}", "capability.lock", title: "Check for Locked locks", required: false, multiple:true, submitOnChange: true
            if (settings."locksflip${mode}") {
                input "locksopen${mode}", "bool", title: "Unlock them?", required: false
            }
        }

        section("Choose Switch(s)") {
            paragraph "Notify if any of these selected switches are On/Off when the SHM changes to $name"
            input "switches${mode}", "capability.switch", title: "Check for switches left On", required: false, multiple:true, submitOnChange: true
            if (settings."switches${mode}") {
                input "switchesoff${mode}", "bool", title: "Turn them off?", required: false
            }
            input "switchesflip${mode}", "capability.switch", title: "Check for switches left Off", required: false, multiple:true, submitOnChange: true
            if (settings."switchesflip${mode}") {
                input "switcheson${mode}", "bool", title: "Turn them on?", required: false
            }
        }

        section("Choose Windows Shade/Blind(s)") {
            paragraph "Notify if any of these selected window shades/blinds are Open/Closed when SHM changes to $name"
            input "shades${mode}", "capability.windowShade", title: "Check for shades left Open", required: false, multiple:true, submitOnChange: true
            if (settings."shades${mode}") {
                input "shadesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "shadesflip${mode}", "capability.windowShade", title: "Check for shades left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."shadesflip${mode}") {
                input "shadeson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Choose Valve(s)") {
            paragraph "Notify if any of these selected valves are Open/Closed when the SHM changes to $name"
            input "valves${mode}", "capability.valve", title: "Check for valves left Open", required: false, multiple:true, submitOnChange: true
            if (settings."valves${mode}") {
                input "valvesoff${mode}", "bool", title: "Close them?", required: false
            }
            input "valvesflip${mode}", "capability.valve", title: "Check for valves left Closed", required: false, multiple:true, submitOnChange: true
            if (settings."valvesflip${mode}") {
                input "valveson${mode}", "bool", title: "Open them?", required: false
            }
        }

        section("Run Routine") {
            def phrases = location.helloHome?.getPhrases()
            phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines
            input "homePhrase${mode}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: settings."homePhrase${mode}"
        }
        
        section("Custom State Options") {
            paragraph "Enable this option to delay (about a minute or two) before checking/taking actions for any devices after a SHM state change\nThis can allow for an exit delay or for apps to complete their tasks"
            input name: "delayAction${mode}", title: "Delay by (seconds)", type: "number", required: false, range: "1..*"

            paragraph "Enabling state specific notifications will override over any general notifications defined on the first page"
            input "modeOverrideNotifications${mode}", "bool", title: "Enable $name state specific notifications", required: false,  submitOnChange: true
            if (settings."modeOverrideNotifications${mode}") {
                input("recipients${mode}", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                    input name: "notify${mode}", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                    paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '*'. E.g. 5551234567*4447654321"
                    input name: "sms${mode}", title: "Send SMS notification to (optional):", type: "phone", required: false
                }
            }
        }
    }
}

def installed() {
    log.debug "Installed"

    subscribeToEvents()
}

def updated() {
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.trace settings

    state.queuedActions = [] // initialize it
    
    subscribe(location, "alarmSystemStatus" , modeChangeHandler)

    // Check for new versions of the code
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Integer randomDayOfWeek = random.nextInt(7-1) + 1 // 1 to 7
    schedule("0 0 " + randomHour + " ? * " + randomDayOfWeek, checkForCodeUpdate) // Check for code updates once a week at a random day and time between 10am and 6pm
}

def modeChangeHandler(evt = null) {
    unschedule(modeChangeHandler) // If there are any pending from previous runs cancel them
    log.debug "SHM state change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking/actions"}"

    def mode = location.currentState("alarmSystemStatus")?.value // This should the current SHM state

    // Check if we need a delayed actions for this state
    if (evt && settings."delayAction${mode}") {
        log.trace "Delaying checking/actions by ${settings."delayAction${mode}"} seconds"
        runIn(settings."delayAction${mode}", modeChangeHandler) // It automatically overwrites old schedules so we only get the latest
        return
    }

    // Check for open doors/windows left open
    if (settings."doors${mode}") {
        def message = ""
        for (door in settings."doors${mode}") {
            if (door.currentValue("contact") == "open") {
                message += ", $door"
            } else {
                log.debug "$door is currently Closed"
            }
        }

        if(message) {
            message = "These doors were Open when SHM was changed to $mode" + message

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No doors/windows found to check for open when SHM was changed to $mode"
    }    

    // Check for open doors/windows left closed
    if (settings."doorsflip${mode}") {
        def message = ""
        for (door in settings."doorsflip${mode}") {
            if (door.currentValue("contact") == "closed") {
                message += ", $door"
            } else {
                log.debug "$door is currently Open"
            }
        }

        if(message) {
            message = "These doors were Closed when SHM was changed to $mode" + message

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No doors/windows found to check for closed when SHM was changed to $mode"
    }    

    // Check for switches left on
    if (settings."switches${mode}") {
        def message = ""
        for (switchs in settings."switches${mode}") {
            if (switchs.currentValue("switch") == "on") {
                message += ", $switchs"
                if (settings."switchesoff${mode}") {
                    switchs.off()
                }
            } else {
                log.debug "$switchs is currently Off"
            }
        }

        if(message) {
            if (settings."switchesoff${mode}") {
                message = "These switches were On when SHM was changed to $mode, turning them Off" + message
            } else {
                message = "These switches were On when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No switches found to check for on when SHM was changed to $mode"
    }    

    // Check for switches left off
    if (settings."switchesflip${mode}") {
        def message = ""
        for (switchs in settings."switchesflip${mode}") {
            if (switchs.currentValue("switch") == "off") {
                message += ", $switchs"
                if (settings."switcheson${mode}") {
                    switchs.on()
                }
            } else {
                log.debug "$switchs is currently On"
            }
        }

        if(message) {
            if (settings."switcheson${mode}") {
                message = "These switches were Off when SHM was changed to $mode, turning them On" + message
            } else {
                message = "These switches were Off when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No switches found to check for off when SHM was changed to $mode"
    }    

    // Check for locks left unlocked
    if (settings."locks${mode}") {
        def message = ""
        for (lock in settings."locks${mode}") {
            if (lock.currentValue("lock") == "unlocked") {
                message += ", $lock"
                if (settings."locksoff${mode}") {
                    lock.lock()
                }
            } else {
                log.debug "$lock is currently Locked"
            }
        }

        if(message) {
            if (settings."locksoff${mode}") {
                message = "These locks were Unlocked when SHM was changed to $mode, Locking them" + message
            } else {
                message = "These locks were Unlocked when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No locks found to check for unlocked when SHM was changed to $mode"
    }    

    // Check for locks left locked
    if (settings."locksflip${mode}") {
        def message = ""
        for (lock in settings."locksflip${mode}") {
            if (lock.currentValue("lock") == "locked") {
                message += ", $lock"
                if (settings."locksopen${mode}") {
                    lock.unlock()
                }
            } else {
                log.debug "$lock is currently Unlocked"
            }
        }

        if(message) {
            if (settings."locksopen${mode}") {
                message = "These locks were Locked when SHM was changed to $mode, Unlocking them" + message
            } else {
                message = "These locks were Locked when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No locks found to check for locked when SHM was changed to $mode"
    }    

    // Check for garage doors left open
    if (settings."garagedoors${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoors${mode}") {
            if (garagedoor.currentValue("door") != "closed") {
                message += ", $garagedoor"
                if (settings."garagedoorsoff${mode}") {
                    garagedoor.close()
                }
            } else {
                log.debug "$garagedoor is currently Closed"
            }
        }

        if(message) {
            if (settings."garagedoorsoff${mode}") {
                message = "These doors were Open when SHM was changed to $mode, Closing them" + message
            } else {
                message = "These doors were Open when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No garage doors found to check for open when SHM was changed to $mode"
    }    

    // Check for garage doors left closed
    if (settings."garagedoorsflip${mode}") {
        def message = ""
        for (garagedoor in settings."garagedoorsflip${mode}") {
            if (garagedoor.currentValue("door") != "open") {
                message += ", $garagedoor"
                if (settings."garagedoorsopen${mode}") {
                    garagedoor.open()
                }
            } else {
                log.debug "$garagedoor is currently Open"
            }
        }

        if(message) {
            if (settings."garagedoorsopen${mode}") {
                message = "These doors were Closed when SHM was changed to $mode, Opening them" + message
            } else {
                message = "These doors were Closed when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No garage doors found to check for closed when SHM was changed to $mode"
    }    

    // Check for shades left open
    if (settings."shades${mode}") {
        def message = ""
        for (shade in settings."shades${mode}") {
            if (shade.currentValue("windowShade") != "closed") {
                message += ", $shade"
                if (settings."shadesoff${mode}") {
                    shade.close()
                }
            } else {
                log.debug "$shade is currently Closed"
            }
        }

        if(message) {
            if (settings."shadesoff${mode}") {
                message = "These shades were Open when SHM was changed to $mode, Closing them" + message
            } else {
                message = "These shades were Open when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No window shades found to check for open when SHM was changed to $mode"
    }    

    // Check for window shades left closed
    if (settings."shadesflip${mode}") {
        def message = ""
        for (shade in settings."shadesflip${mode}") {
            if (shade.currentValue("windowShade") != "open") {
                message += ", $shade"
                if (settings."shadeson${mode}") {
                    shade.open()
                }
            } else {
                log.debug "$shade is currently Open"
            }
        }

        if(message) {
            if (settings."shadeson${mode}") {
                message = "These shades were Closed when SHM was changed to $mode, Opening them" + message
            } else {
                message = "These shades were Closed when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No window shades found to check for closed when SHM was changed to $mode"
    }    

    // Check for valves left open
    if (settings."valves${mode}") {
        def message = ""
        for (valve in settings."valves${mode}") {
            if (valve.currentValue("valve") == "open" || valve.currentValue("contact") == "open") { // ST doesn't use valve due to firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valvesoff${mode}") {
                    valve.close()
                }
            } else {
                log.debug "$valve is currently Closed"
            }
        }

        if(message) {
            if (settings."valvesoff${mode}") {
                message = "These valves were Open when SHM was changed to $mode, Closing them" + message
            } else {
                message = "These valves were Open when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No valves found to check for open when SHM was changed to $mode"
    }    

    // Check for valves left closed
    if (settings."valvesflip${mode}") {
        def message = ""
        for (valve in settings."valvesflip${mode}") {
            if (valve.currentValue("valve") == "closed" || valve.currentValue("contact") == "closed") { // ST doesn't use valve firmware bug - https://community.smartthings.com/t/documentation-error-for-valve-or-platform-bug/88037/19
                message += ", $valve"
                if (settings."valveson${mode}") {
                    valve.open()
                }
            } else {
                log.debug "$valve is currently Open"
            }
        }

        if(message) {
            if (settings."valveson${mode}") {
                message = "These valves were Closed when SHM was changed to $mode, Opening them" + message
            } else {
                message = "These valves were Closed when SHM was changed to $mode" + message
            }

            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No valves found to check for closed when SHM was changed to $mode"
    }
    
    // Run routine if required, do this last as it can timeout
    if (settings."homePhrase${mode}") {
        def message = "Running routine ${settings."homePhrase${mode}"} when SHM was changed to $mode"
        location.helloHome.execute(settings."homePhrase${mode}")

        if(message) {
            log.info message

            if (settings."modeOverrideNotifications${mode}") {
                log.trace "Using mode specific notifications"
                sendMessages(mode, message)
            } else {
                log.trace "Using general notifications"
                sendMessages(null, message)
            }
        }
    } else {
        log.trace "No routines to run when SHM was changed to $mode"
    }
}

private sendText(number, message) {
    if (number) {
        def phones = number.split("\\*")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private sendMessages(mode, message) {
    if (mode) {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, settings."recipients${mode}")
        } else {
            if (settings."notify${mode}") {
                sendPush message
            }

            if (settings."sms${mode}") {
                sendText(settings."sms${mode}", message)
            }
        }
    } else {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, recipients)
        } else {
            if (notify) {
                sendPush message
            }

            if (sms) {
                sendText(sms, message)
            }
        }
    }
}

def checkForCodeUpdate(evt) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "SHM State Change Notification and Actions"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"
                if (appVersion > clientVersion()) {
                    def msg = "New version of app ${app.label} available: $appVersion, current version: ${clientVersion()}.\nPlease visit $serverUrl to get the latest version."
                    log.info msg
                    if (!disableUpdateNotifications) {
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def caps = []
                shmModes.each { mode, name ->
                    caps.add(settings."doors${mode}")
                    caps.add(settings."doorsflip${mode}")
                    caps.add(settings."garagedoors${mode}")
                    caps.add(settings."garagedoorsflip${mode}")
                    caps.add(settings."locks${mode}")
                    caps.add(settings."locksflip${mode}")
                    caps.add(settings."switches${mode}")
                    caps.add(settings."switchesflip${mode}")
                    caps.add(settings."shades${mode}")
                    caps.add(settings."shadesflip${mode}")
                    caps.add(settings."valves${mode}")
                    caps.add(settings."valvesflip${mode}")
                }
                caps?.each {
                    def devices = it?.findAll { it.hasAttribute("codeVersion") }
                    for (device in devices) {
                        if (device) {
                            def deviceName = device?.currentValue("dhName")
                            def deviceVersion = ret.data?."$deviceName"
                            if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                                def msg = "New version of device ${device?.displayName} available: $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nPlease visit $serverUrl to get the latest version."
                                log.info msg
                                if (!disableUpdateNotifications) {
                                    sendPush(msg)
                                }
                            } else {
                                log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                            }
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}


// THIS IS THE END OF THE FILE


