/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "04.02.07"
}

/*
* Copyright RBoy Apps, redistribution or reuse of code or any changes is not allowed without permission
* Works with all Z-Wave Locks including Schlage, Yale, Kiwkset, Monoprice, DanaLock, IDLock, Samsung and August
*
* Change Log
* 2018-9-24 - (v04.02.07) Fix for IDLock remote (ST mobile app) lock/unlock being reported incorrectly and audio controls, added polling every 12 hours for broken ST pollster
* 2018-9-6 - (v04.02.06) Added fingerprint for more Kwikset models, added support for reporting manual locking and unlocking for KeyWe models
* 2018-8-20 - (v04.02.05) Added fingerprint for Yale model YRL-220-ZW-605 and report all keypad unlocked events from Schlage FE599
* 2018-8-16 - (v04.02.04) Support for broken polling, poll every 12 hours and check battery atleast once every 24 hours
* 2018-8-2 - (v04.02.03) Added basic support for new ST app
* 2018-7-28 - (v04.02.02) Updated to match ST's new lock capabilities
* 2018-7-24 - (v04.02.01) Patch for9some loc6 which don't generate a cod6 report after setting for more Kwikset models, added support for reporting manual locking and unlocking for KeyWe models
* 2018-7-18 - (v04.02.00) Added support for IDLock 150 model and KeyWe GKW-2000D lock
* 2018-6-5 - (v04.01.00) Added support for Popp z-wave keypads, Lockstar locks and fix Schlage FE599 lock state issue (when unlocked using a code while it's unlocked), added option for enabling low audio volume for Yale locks
* 2018-5-2 - (v04.00.10) Added support for Samsung SHP/SHS models (APAC)
* 2018-5-18 - (v04.00.09) Patch for ST platform changes causing DTH not to load
* 2018-5-9 - (v04.00.08) Added more tamper detection events
* 2018-5-8 - (v04.00.07) Dont' show sensitivity when alarm is off, improve response for settings alarm/sensitivity for Schlage BE469 locks, force tamper reports even if before reset was complete, display configuration in recently screen with better text
* 2018-3-19 - (v04.00.05) Added support for configuring Yale wrong code entry keypad shutdown time
* 2018-2-14 - (v04.00.04) Update name to be compatible with SmartLocks
* 2018-2-13 - (v04.00.03) Limit relock patch only for FE599
* 2018-1-23 - (v04.00.02) Workaround for pairing issue causing zwInfo showing model as 0000 causing tiles to go missing
* 2018-1-21 - (v04.00.01) Added fingerprints for Vivint Kwikset locks
* 2018-1-16 - (v04.00.00) Updated to support SmartLock app, pinLength is now codeLength, maxCodes introduced, added support for Samsung locks, fix for Yale commercial/residential audio modes
* 2017-11-7 - (v03.05.01) Fixed audio on/off for Yale (it was inverted, on turned it off and vice verse)
* 2017-10-19 - (v03.05.00) Added support for Danalock V3, added support for one touch locking/lock and leave tile
* 2017-10-18 - (v03.04.03) Update tile layout with ST mobile app release 2.8.0
* 2017-10-9 - (v03.04.02) August lock pro MSR patch, only supports secure commands
* 2017-10-5 - (v03.04.01) August lock pro patch for faulty firmware reporting unknown status
* 2017-10-4 - (v03.04.00) Yale assure lock keypad lock detection
* 2017-9-25 - (v03.03.06) Added more Yale Assure locks
* 2017-9-12 - (v03.03.06) Updated base DTH to sync with ST changes
* 2017-8-15 - (v03.03.06) Added support for August Z-Wave locks
* 2017-6-15 - (v03.03.06) When locks are updated(), refresh the MSR incase the lock has been replaced through ST, correctly report Yale and Danalock RF lock/unlock
* 2017-5-29 - (v03.03.05) Added support for more locks (Yale Assa Abloy) and Yale Bluetooth, updated code to latest Yale specifications
* 2017-5-24 - (v03.03.04) Fixed issue with Schlage keypad lock/unlock being reported as Master Code
* 2017-5-23 - (v03.03.03) Added support for reporting Yale RFID tags/user slots
* 2017-5-23 - (v03.03.02) Added support for FE599 series invalid code detection
* 2017-5-4 - (v03.03.01) Updated color scheme to match ST UX recommendations
* 2017-4-19 - (v.03.02.03) Added more Yale fingerprints for Yale Assure Lock and patch for Yale Master Code reporting (code 0 and code 251)
* 2017-3-13 - (v.3.2.2) Don't show unknown and reset states in the recently logs of device
* 2017-2-25 - (v3.2.2) Added fingerprints and identification for Yale Conexis L1
* 2017-2-3 - (v3.2.1) Fix for IDE some users were facing while installing the device handler
* 2017-1-21 - (v3.2.0) Added support for Yale commercial locks (e.g. nexTouch) and tiles for DPS sensor, tampering and fire/smoke alarm
* 2017-1-2 - (v3.1.3) Added ability to report door state for IDLock and Yale DPS, Motion Sensor (Schlage) and Smoke Detector (IDLock) capabilties also need to be uncommented if required
* 2016-11-2 - Added capability tamper alert and improved tamper detection
* 2016-10-23 - Added ability to check for new code versions, check for Yale duplicate codes and read Schlage pin code lengths and save it in `pinLength`
* 2016-10-21 - Added support for Danalock including RF and Keypad
* 2016-10-6 - Added support for FE469
* 2016-9-6 - Do not report advanced feature status in device stream to avoid confusing users
* 2016-8-27 - Added support for enabling/disabling beeper on Schlage FE5xx/BE3xx locks
* 2016-8-23 - Updated battery icon
* 2016-8-19 - Now unsupported features will show up as blank tiles on the screen
* 2016-8-8 - Fix for working with IDLock locks configuration
* 2016-7-27 - Added support for Yale Keyless Connected YD-01 UK lock, more Kwikset and Schlage models, with generic models for future proof support
* 2016-7-25 - Removed warning for Kiwkset, it does not support remote programming, only reading
* 2016-7-24 - Added support for non secure classes (battery, configuration for some locks like IDLock)
* 2016-7-23 - Added support for IDLock RFID lock and fire sensor
* 2016-7-19 - Harmonized events type reporting using data.type, `outsideLockEvent` is no longer used
* 2016-7-14 - Bugfix for Yale lock using code
* 2016-7-13 - Added support for Yale one touch keypad lock and outsideLockEvent notification
* 2016-7-13 - Added support for Yale alarm notifications, Yale lock codes and Yale specific configuration
* 2016-7-13 - Fixed reporting invalidCode instead of tamper for invalid code entries
* 2016-7-11 - Added more support for external button locking with code and for Yale locks
* 2016-7-10 - Added support for external keypad button locked attribute `outsideLockEvent` and tested with BE469
* 2016-5-11 - Kwikset 916/914/910 share same MSR and fingerprint
* 2016-4-20 - Added DH version in setup page
* 2016-4-8 - Fix for invalidCode not always being reported
* 2016-3-31 - Added fingerprint ID's for BE469, FE599, BE369, Kwiket 914, Yale Keyfree
* 2016-3-22 - Added support for 6th generation of Yale locks
* 2016-3-22 - Changed the icon for the sensivitity
* 2016-3-22 - Standardized coding standard
* 2016-3-21 - Added support for Enabling/Disabling Audio/Beeper for Schlage and Yale locks including commands enableAudio and disableAudio
* 2016-3-15 - Fixed updated function
* 2016-3-14 - Added support for Kiwkset 916 and reporting beeper/buzzer via attribute 'beeper'
* 2016-2-15 - Added identification of generic lock types from Schlage
* 2016-2-14 - Improvement to initial setup to associate lock and get MSR
* 2016-2-10 - Added support for additional Yale lock devices
* 2016-2-7 - Fix Support for Yale lock Vacation Mode (Key Code enable/disable)
* 2016-2-6 - Fixed Yale MSR code check
* 2016-2-6 - Added support for Yale locks AutoLock and Keypad disable
* 2016-2-6 - Fixed refresh on configuration
* 2016-2-3 - Fixed an issue with keypad code enable/disable not working for the BE369
* 2016-2-3 - Support future version of Schlage locks and fix issue with unsupported Schlage locks (now prompts user to report the new locks to developer but still tries to configure it)
* 2016-2-2 - Set alarm and sensitive attributes to empty if not supported
* 2016-2-2 - Fixed alarm status not updating on the tile always, indicate when features are not supported by lock
* 2016-1-27 - Fix for battery UI broken after upgrade to ST iOS 2.0.8 app
* 2016-1-27 - Fixed issue with motion sensor for BE469 showing up as 0 in SHM on fresh installation
* 2016-1-23 - Fixed a bug in getting the MSR for a new lock setup
* 2016-1-19 - Fixed a bug in base code, codeReport notifications were not always sent to the SmartApp
* 2015-12-19 - Updated base code and cleaned up
* 2015-12-9 - Added Dummy commented code for enabling switch capabilities for the lock, uncomment code to enable switch capabilities as requested by users
* 2015-12-3 - Fix for delay/error in initialization not populating the features sometimes
* 2015-11-29 - Tweaked the timeout for the relock notification for non motorized deadbolts to 3 seconds
* 2015-11-29 - Added fix for non motorized deadbolt locks like FE599 not reporting locked after user unlocks the door using a code and it relocks automatically
* 2015-11-21 - Readded support for attribute "invalidCode" when a user enters an invalid code too many times
* 2015-11-20 - Corrected text from Auto unlock to Auto lock
* 2015-11-2 - Added support to set Alarm and Sensivity levels directly from a SmartApp using setAlarm ("off", "alert", "tamper", "forced")and setSensitivity ("highest", "high", "medium", "low", "lowest") commands
* 2015-9-29 - Added support for Schlage BE369
* 2015-9-26 - Updated layout and colors
* 2015-9-23 - Updated colors and layout
* 2015-9-19 - Added support for MultiAttribute Tiles
* 2015-7-22 - Updated base code to sync with SmartThings (removed status "invalidCode" and use "tamper" instead)
* 2015-7-15 - Added support for BE468
* 2015-7-15 - Improved Jammed status support
* 2015-6-5 - Added support to get battery level on manual refresh
* 2015-6-5 - Added support for BE469 and FE599 Schlage locks
* 2015-2-13 - Added support for auto lock and vacation mode
* 2015-1-20 - Added support for configuring alarm mode and alarm sensitivity
* 2015-1-20 - Added support for motion sensor capability for alarm event
* 2015-1-20 - Added support for door jammed status using capability "invalidCode"
*
*  Copyright 2014 SmartThings
*
*  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
*  in compliance with the License. You may obtain a copy of the License at:
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
*  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
*  for the specific language governing permissions and limitations under the License.
*
*/

metadata {
    // Automatically generated. Make future change here.
    definition (name: "Universal Z-Wave Lock With Alarms", namespace: "rboy", author: "RBoy Apps", mnmn: "SmartThings", vid:"generic-lock") {
        capability "Actuator"
        capability "Lock"
        capability "Polling"
        capability "Refresh"
        capability "Sensor"
        capability "Lock Codes"
        capability "Battery"
        capability "Health Check"
        capability "Configuration"
        capability "Tamper Alert"
        capability "Smoke Detector" //  Fire/Smoke Sensor alerts for IDLock
        capability "Contact Sensor" // Door Open/Close state capability for IDlock and Yale DPS
        //capability "Motion Sensor" // replaced with Tamper Alert (Uncomment this to report as Motion Sensor for tamper alarm alerts for Schlage)
        //capability "Switch" // Uncomment this to enable Switch capability interfaces on lock

        attribute "alarm", "string"
        attribute "sensitive", "string"
        attribute "codeunlock", "string"
        attribute "autolock", "string"
        attribute "lockStatus", "string"
        attribute "invalidCode", "string"
        attribute "beeper", "string"
        attribute "maxPINLength", "number"
        attribute "minPINLength", "number"
        //attribute "codeLength", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        //attribute "maxCodes", "number" // TODO: Do we need to define this or is this automatically done now with the new DTH capability
        attribute "codeVersion", "string"
        attribute "dhName", "string"
        attribute "contactX", "string"
        attribute "onetouchlock", "string"


        //command "unlockwtimeout" // TODO Do we need this anymore or is it defined internally with the new DTH type
        command "alarmToggle"
        command "setAlarm", ["string"]
        command "sensitiveToggle"
        command "setSensitivity", ["string"]
        command "disableKeypad"
        command "enableKeypad"
        command "enableAutolock"
        command "disableAutolock"
        command "disableAudio"
        command "enableAudio"
        command "disableOneTouchLock"
        command "enableOneTouchLock"

        fingerprint deviceId: "0x4004", inClusters: "0x98"
        fingerprint deviceId: "0x4003", inClusters: "0x98"
        fingerprint deviceId: "0x4003", inClusters: "0x85,0x73,0x72,0x98" // Schalge BE369, Schlage FE599
        fingerprint deviceId: "0x4003", inClusters: "0x22,0x72,0x7A,0x98,0x86" // Schlage BE469
        fingerprint deviceId: "0x4003", inClusters: "0x72,0x86,0x98" // Kwikset 910/916/914, Yale KeyFree UK

        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"4004", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"98" // Generic Z-Wave lock
        fingerprint type:"4003", cc:"72,86,98", deviceJoinName:"Kwikset/Yale Z-Wave Lock" // Generic Kwikset/Yale
        fingerprint type:"4003", cc:"85,73,72,98", deviceJoinName:"Schlage BE3xx/FE5xx Z-Wave Lock" // Generic Schalge BE369, Schlage FE599
        fingerprint type:"4003", cc:"22,72,7A,98,86", deviceJoinName:"Schlage BE4xx Z-Wave Lock" // Schlage Generic BE4xx

        // Specific models
        fingerprint mfr:"003B", prod:"634B", model:"5044", deviceJoinName:"Schlage FE369 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"634B", model:"504C", deviceJoinName:"Schlage FE599 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6349", deviceJoinName:"Schlage Touchscreen Deadbolt BE468 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6349", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE468NX CAM 619 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", deviceJoinName:"Schlage Touchscreen Deadbolt BE469 Z-Wave Lock" // Generic Schlage BE469
        fingerprint mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt FE469NX Z-Wave Lock" // Generic Schlage FE469
        fingerprint mfr:"003B", prod:"6341", model:"5044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CAM 716 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", model:"7750", deviceJoinName:"Schlage Touchscreen Deadbolt BE469NX CEN 716 Z-Wave Lock"
        fingerprint mfr:"003B", prod:"6341", model:"4044", deviceJoinName:"Schlage Touchscreen Deadbolt BE469IR Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0642", deviceJoinName:"Kwikset 916 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0436", deviceJoinName:"Kwikset 914 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0336", deviceJoinName:"Kwikset 912 Z-Wave Lock"
        fingerprint mfr:"0090", prod:"0001", model:"0236", deviceJoinName:"Kwikset 910 Z-Wave Lock"
		fingerprint mfr:"0090", prod:"0003", model:"0742", deviceJoinName: "Kwikset Obsidian Lock" // zw:Fs type:4003 mfr:0090 prod:0003 model:0742 ver:4.10 zwv:4.34 lib:03 cc:5E,72,5A,98,73,7A sec:86,80,62,63,85,59,71,70,4E,8B,4C,5D role:07 ff:8300 ui:8300, KWIKSET OBSIDIAN
        fingerprint mfr:"0090", prod:"0001", model:"0001", deviceJoinName:"Kwikset 91x Z-Wave lock" // Kwikset 91x Series Generic Z-Wave
        fingerprint mfr:"0090", prod:"0001", deviceJoinName:"Kwikset Z-Wave lock" // Kwikset Generic Z-Wave, model:"0001"
        fingerprint mfr:"0090", prod:"0003", deviceJoinName:"Vivint (Kwikset) Z-Wave lock" // Kwikset Vivint Generic Z-Wave, model:"0003"
        fingerprint mfr:"0090", prod:"0003", model:"0541", deviceJoinName:"KwikSet SmartCode 888 Touchpad Deadbolt Door Lock" //zw:Fs type:4003 mfr:0090 prod:0003 model:0541 ver:4.79 zwv:4.34 lib:03 cc:5E,72,5A,98,73,7A sec:86,80,62,63,85,59,71,70,5D role:07 ff:8300 ui:8300, Kwikset Vivint 912
        fingerprint mfr:"0109", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint mfr:"0129", prod:"0002", model:"0000", deviceJoinName:"Yale Real Living Touchscreen Deadbolt"
        fingerprint mfr:"0109", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint mfr:"0129", prod:"0002", model:"FFFF", deviceJoinName:"Yale Real Living Touchscreen Lever Lock"
        fingerprint mfr:"0109", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint mfr:"0129", prod:"0001", model:"0000", deviceJoinName:"Yale Real Living Push Button Lever Lock"
        fingerprint mfr:"0109", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt"
        fingerprint mfr:"0129", prod:"0004", model:"0000", deviceJoinName:"Yale Real Living Push Button Deadbolt" // YRD 210
        fingerprint mfr:"0109", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint mfr:"0129", prod:"0004", model:"0800", deviceJoinName:"Yale YRD110"
        fingerprint mfr:"0109", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint mfr:"0129", prod:"0002", model:"0800", deviceJoinName:"Yale YRD120"
        fingerprint mfr:"0129", prod:"8002", model:"1600", deviceJoinName:"Yale Assure with Bluetooth (YRD446-NR-605)"
        fingerprint mfr:"0129", prod:"8002", model:"1000", deviceJoinName:"Yale Assure with Bluetooth (YRD446-ZW-2619)"
        fingerprint mfr:"0129", prod:"0006", model:"0000", deviceJoinName:"Yale Keyfree Connected/Conexis L1" // UK
        fingerprint mfr:"0129", prod:"0066", model:"0000", deviceJoinName:"Yale Conexis L1 SD-L1000-CH" // Safe.co.uk
        fingerprint mfr:"0129", prod:"0007", model:"0000", deviceJoinName:"Yale Keyless Connected YD-01" // UK - YD-01-CON-ZW-CH
        fingerprint mfr:"0129", prod:"0040", model:"0000", deviceJoinName:"Yale YDM3168" // Italy
        fingerprint mfr:"0129", prod:"8001", model:"0B00", deviceJoinName:"Yale nexTouch Wireless Touchscreen" // Yale Commercial
        fingerprint mfr:"0129", prod:"0600", model:"8004", deviceJoinName:"Yale Assure Push Button Lock" // Yale Assa Abloy series
        fingerprint mfr:"0129", prod:"0600", model:"8002", deviceJoinName:"Yale Assure Touch Screen Lock" // Yale Assa Abloy series
		fingerprint mfr:"0129", prod:"8002", model:"0600", deviceJoinName:"Yale Assure Lock" //YRD416, YRD426, YRD446, YRD226 Bluetooth
		fingerprint mfr:"0129", prod:"0007", model:"0001", deviceJoinName:"Yale Keyless Connected Smart Door Lock"
		fingerprint mfr:"0129", prod:"8004", model:"0600", deviceJoinName:"Yale Assure Lock Push Button Deadbolt" //YRD216
        fingerprint mfr:"0129", prod:"6600", model:"0002", deviceJoinName:"Yale Conexis Lock" // Yale Conexis
        fingerprint mfr:"0129", prod:"0001", model:"0409", deviceJoinName: "Yale Touchscreen Lever Door Lock" // YRL-220-ZW-605
        fingerprint mfr:"0230", prod:"0003", model:"0001", deviceJoinName:"IDLock 101 Z-Wave/RFID Lock" // zw:Fs type:4003 mfr:0230 prod:0003 model:0001 ver:1.00 zwv:4.05 lib:03 cc:5E,72,98,5A,80,73,70 sec:86,62,63,85,59,71,7A role:07 ff:8300 ui:8300
        fingerprint mfr:"0373", prod:"0003", model:"0001", deviceJoinName:"IDLock 150 Z-Wave/RFID Lock" // zw:Fs type:4003 mfr:0373 prod:0003 model:0001 ver:1.05 zwv:4.05 lib:03 cc:5E,72,98,5A,73,70 sec:86,62,63,85,59,71,7A,80 role:07 ff:8300 ui:8300
        fingerprint mfr:"010E", prod:"0008", model:"0002", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Circle
        fingerprint mfr:"010E", prod:"0008", model:"0001", deviceJoinName:"DanaLock V2 BLE, Z-Wave EU" // Square
        fingerprint mfr:"010E", prod:"0009", model:"0001", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Square
        fingerprint mfr:"010E", prod:"0009", model:"0002", deviceJoinName:"DanaLock Vv BLE, Z-Wave EU" // V3 Circle
        fingerprint mfr:"033F", prod:"0001", model:"0001", deviceJoinName:"August Lock" // August
        fingerprint mfr:"022E", prod:"0001", model:"0001", deviceJoinName:"Samsung Digital Lock" // SHP-DS705, SHP-DHP728, SHP-DHP525
        fingerprint mfr:"032F", prod:"0003", model:"0001", deviceJoinName:"Samsung Digital Lock" // SHS-H505, SHSP717, SHS-P718, SHP-DP727, SHP-DP728 - APAC HMDM100 module
        fingerprint mfr:"015e", prod:"8015", model:"0001", deviceJoinName:"Locstar LS-8015-ZW Single Latch Door Lock"
        fingerprint mfr:"015e", prod:"8015", model:"0003", deviceJoinName:"Locstar LS-8015-ZW-MM-BG Lock" // zw:Fs type:4003 mfr:015E prod:8015 model:0003 ver:2.01 zwv:3.99 lib:03 cc:5E,86,72,5A,85,59,73,4C,98 sec:62,63,71,4E,77,70,8B,5D,80,20 role:07 ff:8001 ui:8000
        fingerprint mfr:"037B", prod:"0002", model:"0001", deviceJoinName:"KeyWe GKW-2000D Z-Wave Lock" // Guardtec Inc.
        
        // Keypads
        fingerprint type:"0701", mfr:"0154", prod:"0005", model:"0002", deviceJoinName:"Popp Universal Z-Wave Key Pad" // ver:1.08 zwv:4.54 lib:02 cc:5E,7A,73,80,84,5A,98,86,72 sec:30,71,70,59,85,5B,63 secOut:62 role:03 ff:8300 ui:8300
    }

    simulator {
        status "locked": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
        status "unlocked": "command: 9881, payload: 00 62 03 00 00 00 FE FE"

        reply "9881006201FF,delay 4200,9881006202": "command: 9881, payload: 00 62 03 FF 00 00 FE FE"
        reply "988100620100,delay 4200,9881006202": "command: 9881, payload: 00 62 03 00 00 00 FE FE"
    }

    preferences {
        input title: "", description: "Universal Z-Wave Lock Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "YALE LOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Set the audio volume to low instead of high (enable only if your lock supports it)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleAudioLevelLow", "bool", title:"Use low volume", description: "Enable low audio volume", required: false, displayDuringSetup: false)
        input title: "", description: "Number of invalid code entries before the lock sends a tamper alarm", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleWrongCodeLimit", "number", title:"Wrong code entry limit", description: "Wrong code entry limit", defaultValue: "5", range: "1..7", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds for which the keypad will shutdown after exceeding wrong code entry limit", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleWrongCodeLockout", "number", title:"Wrong code shutdown period", description: "Keypad shutdown time in seconds", defaultValue: "60", range: "10..180", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "5..255", required: false, displayDuringSetup: false)
        input title: "", description: "Enable this if your lock is equipped with a door positioning sensor to sense open/closed doors", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("yaleDPS", "bool", title:"DPS", description: "Door Positioning Sensor", defaultValue: "false", required: false, displayDuringSetup: false)
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "DANALOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Turning speed (torque) of motor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnSpeed", "enum", title:"Motor speed", description: "Speed of locking and unlocking", defaultValue: "3", options: danaTurnOptions, required: false, displayDuringSetup: false)
        input title: "", description: "Brake and go back: (If your lock supports this feature) For doors without levers this feature keeps the latch open for a few seconds after unlocking before turning it back. (0 to disable)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaBrakeGoBack", "number", title:"Brake & Go Back time", description: "Number of seconds to keep the latch open after unlocking", defaultValue: "0", range: "0..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Number of seconds after which the lock will automatically relock when AutoLock is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaRelockTime", "number", title:"AutoLock time", description: "Seconds after which the lock will relock", defaultValue: "30", range: "1..2147483647", required: false, displayDuringSetup: false)
        input title: "", description: "Turn and Go: (If your lock supports this feature) If the lock has the optional rotational sensor installed it will automatically turn if manual rotation is detected", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("danaTurnGo", "bool", title:"Turn & Go", description: "Enable Turn & Go", defaultValue: "false", required: false, displayDuringSetup: false)
        input title: "", description: "", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input title: "", description: "IDLOCK CONFIGURATION OPTIONS", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input title: "", description: "Volume level when audio is enabled", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("idlockVolume", "enum", title:"Volume level", description: "Audio enabled volume", defaultValue: "5", options: idlockVolumeOptions, required: false, displayDuringSetup: false)
        input title: "", description: "Relock if door is unlocked but remains unopened", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("idlockRelock", "bool", title:"Relock", description: "Relock if unopened", defaultValue: "false", required: false, displayDuringSetup: false)
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"toggle", type: "generic", width: 6, height: 4){
            tileAttribute ("device.lock", key: "PRIMARY_CONTROL") {
                attributeState "locked", label:'locked', action:"lock.unlock", icon:"st.locks.lock.locked", backgroundColor:"#00a0dc", nextState:"unlocking"
                attributeState "unlocked", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
                attributeState "unlocked with timeout", label:'unlocked', action:"lock.lock", icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff", nextState:"locking"
                attributeState "unknown", label:"jammed", action:"lock.lock", icon:"st.locks.lock.unknown", backgroundColor:"#e86d13", nextState:"locking"
                attributeState "locking", label:'locking', icon:"st.locks.lock.locked", backgroundColor:"#00a0dc"
                attributeState "unlocking", label:'unlocking', icon:"st.locks.lock.unlocked", backgroundColor:"#ffffff"
            }
            tileAttribute ("device.lockStatus", key: "SECONDARY_CONTROL") {
                attributeState "lockStatus", label:'${currentValue}'
            }
        }
        standardTile("lock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'Lock', action:"lock.lock", icon:"st.locks.lock.locked"
        }
        standardTile("unlock", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'Unlock', action:"lock.unlock", icon:"st.locks.lock.unlocked"
        }
        standardTile("alarm", "device.alarm", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", nextState:"workingoff", backgroundColor:"#ffffff", defaultState: true
            state "off", label:'Alarm Off', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", nextState:"workingoff"
            state "alert", label:'Alert Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "tamper", label:'Tamper Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "forced", label:'Forced Mode', action:"alarmToggle", icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", nextState:"workingon"
            state "workingoff", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOff.png", backgroundColor:"#ffffff"
            state "workingon", label:'...', icon:"http://smartthings.rboyapps.com/images/SecurityOn.png", backgroundColor:"#ffffff"
        }
        standardTile("sensitive", "device.sensitive", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", nextState:"working", backgroundColor:"#ffffff", defaultState: true
            state "highest", label:'Highest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "high", label:'High Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "medium", label:'Medium Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "low", label:'Low Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "lowest", label:'Lowest Sensitivity', action:"sensitiveToggle", icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", nextState:"working"
            state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/Sensitivity.png", backgroundColor:"#ffffff"
        }
        standardTile("onetouchlock", "device.onetouchlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Touch Lock', action:"disableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOn.png", nextState:"working"
            state "disabled", label:'Touch Lock', action:"enableOneTouchLock", icon:"http://smartthings.rboyapps.com/images/ManualControlOff.png", nextState:"working"
            state "working", label:'...', icon:"http://smartthings.rboyapps.com/images/ManualControlWorking.png", backgroundColor:"#cccccc"
        }
        standardTile("codeunlock", "device.codeunlock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'Code Entry On', action:"disableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#ffffff", nextState:"working"
            state "disabled", label:'Code Off', action:"enableKeypad", icon:"st.unknown.zwave.remote-controller", backgroundColor:"#00a0dc", nextState:"working"
            state "working", label:'...', icon:"st.unknown.zwave.remote-controller", backgroundColor:"#cccccc"
        }
        standardTile("autolock", "device.autolock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"working", defaultState: true
            state "enabled", label:'AutoLock', action:"disableAutolock", icon:"st.contact.contact.closed", backgroundColor:"#00a0dc", nextState:"working"
            state "disabled", label:'AutoLock Off', action:"enableAutolock", icon:"st.contact.contact.closed", nextState:"working"
            state "working", label:'...', icon:"st.contact.contact.closed", backgroundColor:"#cccccc"
        }
        standardTile("beeper", "device.beeper", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", nextState:"workingoff", defaultState: true
            state "enabled", label:'Audio On', action:"disableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff", nextState:"workingon"
            state "disabled", label:'Audio Off', action:"enableAudio", icon:"st.quirky.spotter.quirky-spotter-sound-off", nextState:"workingoff"
            state "workingoff", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-off", backgroundColor:"#ffffff"
            state "workingon", label:'...', icon:"st.quirky.spotter.quirky-spotter-sound-on", backgroundColor:"#ffffff"
        }
        valueTile("battery", "device.battery", inactiveLabel: false, width: 2, height: 2) {
            state "battery", label:'${currentValue}%', icon: "http://smartthings.rboyapps.com/images/battery.png", unit:"", backgroundColors:[
                [value: 20, color: "#ff0000"],
                [value: 35, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        standardTile("refresh", "device.lock", inactiveLabel: false, decoration: "flat", width: 2, height: 2) {
            state "default", label:'', action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        standardTile("tamper", "device.tamper", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "detected", label:'TAMPER', backgroundColor:"#e86d13"
            state "clear", label:'', backgroundColor:"#ffffff"
        }
        standardTile("smoke", "device.smoke", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "clear", label:'', icon:"", backgroundColor:"#ffffff", action:"smoke"
            state "detected", label:'SMOKE', icon:"st.alarm.smoke.smoke", backgroundColor:"#e86d13", action:"clear"
        }
        standardTile("contact", "device.contactX", decoration: "flat", width: 2, height: 2) {
            state "unknown", label:'', icon:"", backgroundColor:"#ffffff", defaultState: true
            state "open", label: 'OPEN', icon: "st.contact.contact.open", backgroundColor: "#e86d13"
            state "closed", label: 'CLOSED', icon: "st.contact.contact.closed", backgroundColor: "#00a0dc"
        }
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
            state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
            state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }

        main "toggle"
        details(["toggle", "lock", "unlock", "codeunlock", "autolock", "beeper", "onetouchlock", "alarm", "sensitive", "battery", "contact", "tamper", "smoke", "blank2x", "blank2x", "refresh"])
    }
}

import physicalgraph.zwave.commands.doorlockv1.*
import physicalgraph.zwave.commands.usercodev1.*

private getDanaTurnOptions() {
    return ["1":"Slowest", "2":"Slow", "3":"Normal", "4":"Fast", "5":"Fastest"]
}

private getIdlockVolumeOptions() {
    return ["1":"Lowest", "2":"Low", "3":"Medium", "4":"High", "5":"Higher", "6":"Highest"]
}

private identifyLockModel() {
    log.trace "Identifying specific lock model from database of known models"

    switch (state.MSR) { // check if we have a supported device
        case "003B-6341-5044": // Schlage FE/BE469NX CAM 716
            log.debug "Found Schlage FE/BE469NX CAM 716"
            break

        case "003B-6341-7750": // Schlage FE/BE469NX CEN 716
            log.debug "Found Schlage FE/BE469NX CEN 716"
            break

        case "003B-6341-4044": // Schlage FE/BE469IR V CAM 619
            log.debug "Found Schlage FE/BE469IR V CAM 619"
            break

        case ~/003B-6341-.*/: // Schlage FE/BE469 Series
            log.debug "Found Schlage FE/BE469 Series"
            break

        case "003B-6349-5044": // Schlage BE468
            log.debug "Found Schlage BE468"
            break

        case ~/003B-6349-.*/: // Schlage BE468 Series
            log.debug "Found Schlage BE468 Series"
            break

        case "003B-634B-504C": // Schlage FE599NX CAM 505 ACC 505
            log.debug "Found Schlage FE599NX CAM 505 ACC 505"
            break

        case "003B-634B-5044": // Schlage BE369NX CAM 619
            log.debug "Found Schlage BE369NX CAM 619"
            break

        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series
            log.debug "Found Schlage FE5xx/BE3xx Series"
            break

        case ~/0109-0001-.*/: // Yale Touch Lever
        case ~/0129-0001-.*/: // Yale Touch Lever
            log.debug "Found Yale Touch Lever"
            break

        case ~/0109-0002-.*/: // Yale Touch Deadbolt
        case ~/0129-0002-.*/: // Yale Touch Deadbolt
            log.debug "Found Yale Touch Deadbolt"
            break

        case ~/0109-0003-.*/: // Yale Push Button Lever
        case ~/0129-0003-.*/: // Yale Push Button Lever
            log.debug "Found Yale Push Button Lever"
            break

        case ~/0109-0004-.*/: // Yale Push Button Deadbolt
        case ~/0129-0004-.*/: // Yale Push Button Deadbolt
            log.debug "Found Yale Push Button Deadbolt"
            break

        case ~/0129-0006-.*/: // Yale Keyfree/Conexis L1 Lock
            log.debug "Found Yale Keyfree/Conexis L1 Lock"
            break

        case ~/0129-6600-.*/: // Yale Conexis
        case ~/0129-0066-.*/: // Yale Yale Conexis L1 SD-L1000-CH Safe.co.uk
            log.debug "Found Yale Conexis Lock"
            break

        case ~/0129-0007-.*/: // Yale Keyless Connected YD-01
            log.debug "Found Yale Keyless Connected YD-01"
            break

        case ~/0129-8001-.*/: // Yale nextTouch Wireless Touchscreen
            log.debug "Found Yale nexTouch"
            break

        case ~/0129-8002-.*/: // Yale Assure Lock
            log.debug "Found Yale Assure"
            break

        case ~/0129-8004-.*/: // Yale Yale Assure Lock Push Button Deadbolt
            log.debug "Found Yale Assure Lock Push Button Deadbolt"
            break

        case ~/0129-0600-.*/: // Yale Assure Assa Abloy
            log.debug "Found Yale Assure Assa Abloy Lock"
            break

        case "0090-0001-0642": // Kwikset 916
            log.debug "Found Kwikset 916 Lock"
            break

        case "0090-0001-0436": // Kwikset 914
            log.debug "Found Kwikset 914 Lock"
            break

        case "0090-0001-0336": // Kwikset 912
            log.debug "Found Kwikset 912 Lock"
	        break

        case "0090-0001-0236": // Kwikset 910
            log.debug "Found Kwikset 910 Lock"
            break

        case "0090-0001-0001": // Kwikset 91x Series
            log.debug "Found Kwikset 91x Lock"
            break

        case "0090-0003-0541": // Vivint Kwikset 912 variant
        	log.debug "Found Vivint Kwikset 912 Lock"
        	break
            
        case "0090-0003-0742": // Kwikset Obsidian
        	log.debug "Found Kwikset Obsidian Lock"
        	break

        case ~/0090-0001-.*/: // Generic Kwikset 916/914/910 (last case)
            log.debug "Found Kwikset Lock"
            break
        
        case "0230-0003-0001": // IDLock 101
            log.debug "Found IDLock 101 Lock"
            break

        case "0373-0003-0001": // IDLock 150
            log.debug "Found IDLock 150 Lock"
            break

        case ~/010E-0009-.*/: // Danalock V3
            log.debug "Found Danalock v3"
            break

        case ~/010E-0008-.*/: // Danalock V2
	        log.debug "Found Danalock v2"
    	    break

        case ~/033F-0001-.*/: // August
            log.debug "Found August Lock"
            break

        case ~/022E-0001-.*/: // Samsung
        case ~/032F-0003-.*/:
            log.debug "Found Samsung Digital Lock"
            break
            
       case ~/015e-8015-.*/: // Locstar LS-8015
            log.debug "Found Locstar Lock"
            break

        case ~/0154-0005-.*/: // Popp
            log.debug "Found Popp Keypad"
            break
            
        case "037B-0002-0001": // KeyWe GKW-2000D
        	log.debug "Found KeyWe GKW-2000D"
            break
       
        default:
            log.warn "Unrecognized device. Contact developer with MSR $state.MSR"
	        break
    }
}	

/**
* Called on app installed
*/
def installed() {
    // Device-Watch pings if no device events received for 1 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    schedule("* 0 */12 * * ?", scheduledPoll) // Poll every 12 hours

    if (isSamsungLock()) { // Samsung locks won't allow you to enter the pairing menu when locked, so it must be unlocked
        sendEvent(name: "lock", value: "unlocked", isStateChange: true, displayed: true)
    }

    scheduleInstalledCheck()
}

/**
 * Verify that we have actually received the lock's initial states.
 * If not, verify that we have at least requested them or request them,
 * and check again.
 */
def scheduleInstalledCheck() {
	runIn(120, installedCheck, [forceForLocallyExecuting: false])
}

def installedCheck() {
	if (device.currentState("lock") && device.currentState("battery")) {
		unschedule("installedCheck")
	} else {
		// We might have called updated() or configure() at some point but not have received a reply, so don't flood the network
		if (!state.lastLockDetailsQuery || secondsPast(state.lastLockDetailsQuery, 2 * 60)) {
			def actions = updated()

			if (actions) {
				sendHubCommand(actions.toHubAction())
			}
		}

		scheduleInstalledCheck()
	}
}
/**
* Called on app uninstalled
*/
def uninstalled() {
    def deviceName = device.displayName
    log.trace "[DTH] Executing 'uninstalled()' for device $deviceName"
    sendEvent(name: "lockRemoved", value: device.id, isStateChange: true, displayed: false)
}

/**
* Executed when the user taps on the 'Done' button on the device settings screen. Sends the values to lock.
*
* @return hubAction: The commands to be executed
*/
def updated() {
    log.trace "Updated called settings: $settings"
    // Device-Watch pings if no device events received for 1 hour (checkInterval)
    sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    schedule("* 0 */12 * * ?", scheduledPoll) // Poll every 12 hours
    def hubAction = null
    try {
        def cmds = []

        if (!state.configured) {
            cmds << doConfigure()
        } else {
            state.configured = false
        }

        // Reset things which cannot be polled / updated manually
        resetMotion()
        resetSmoke()
        resetState()

        cmds << refresh()
        cmds << reloadAllCodes()

        hubAction = response(delayBetween(cmds, 4200))
    } catch (e) {
        log.warn "updated() threw $e"
    }

    hubAction
}

/**
 * Configures the device to settings needed by SmarthThings at device discovery time
 *
 */
def configure() {
	log.trace "[DTH] Executing 'configure()' for device ${device.displayName}"
	def cmds = doConfigure()
	log.debug "Configure returning with commands := $cmds"
	cmds
}

/**
 * Returns the list of commands to be executed when the device is being configured/paired
 *
 */
def doConfigure() {
	log.trace "[DTH] Executing 'doConfigure()' for device ${device.displayName}"
	state.configured = true
	def cmds = []
    cmds << configureLock() // Configure lock settings
	cmds << secure(zwave.doorLockV1.doorLockOperationGet())
	cmds << getBatteryState()
    cmds << getCodeLength()
	cmds = delayBetween(cmds, 4200)
    
    state.lastLockDetailsQuery = now()
    
	log.debug "Do configure returning with commands := $cmds"
	cmds
}

def updateTiles() {
    def lockStatusS = (device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown") ? "Alarm ${device.currentState('alarm')?.value}" + (device.currentState('sensitive')?.value && (device.currentState('sensitive')?.value != "unknown") ? "/${device.currentState('sensitive')?.value} | ": " | ") : "") + "Battery ${device.currentState('battery')?.value}%"
    sendEvent(name: "lockStatus", value: lockStatusS, displayed: false, isStateChange: true)
    //log.trace lockStatusS
}

/**
 * Responsible for parsing incoming device messages to generate events
 *
 * @param description: The incoming description from the device
 *
 * @return result: The list of events to be sent out
 *
 */
def parse(String description) {
	//log.trace "[DTH] Executing 'parse(String description)' for device ${device.displayName} with description = $description"

	def result = null
	if (description.startsWith("Err")) {
		if (state.sec) {
			result = createEvent(descriptionText:description, isStateChange:true, displayed:false)
		} else {
			result = createEvent(
					descriptionText: "This lock failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.",
					eventType: "ALERT",
					name: "secureInclusion",
					value: "failed",
					displayed: true,
					)
		}
	} else {
		def cmd = zwave.parse(description, [ 0x98: 1, 0x72: 2, 0x85: 2, 0x86: 1 ])
		if (cmd) {
			result = zwaveEvent(cmd)
		}
	}
    updateTiles() // Update the alarm status on the tiles
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app
	log.info "[DTH] parse() - returning result=$result"
	result
}

/**
 * Responsible for parsing SecurityMessageEncapsulation command
 *
 * @param cmd: The SecurityMessageEncapsulation command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
	//log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with cmd = $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x62: 1, 0x71: 2, 0x80: 1, 0x85: 2, 0x63: 1, 0x98: 1, 0x86: 1])
	if (encapsulatedCommand) {
        //log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation)' with encapsulated cmd = $encapsulatedCommand"
		zwaveEvent(encapsulatedCommand)
	}
}

/**
 * Responsible for parsing NetworkKeyVerify command
 *
 * @param cmd: The NetworkKeyVerify command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.NetworkKeyVerify)' with cmd = $cmd"
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Secure inclusion was successful", isStateChange: true)
}

/**
 * Responsible for parsing SecurityCommandsSupportedReport command
 *
 * @param cmd: The SecurityCommandsSupportedReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityCommandsSupportedReport)' with cmd = $cmd"
	state.sec = cmd.commandClassSupport.collect { String.format("%02X ", it) }.join()
	if (cmd.commandClassControl) {
		state.secCon = cmd.commandClassControl.collect { String.format("%02X ", it) }.join()
	}
	createEvent(name:"secureInclusion", value:"success", descriptionText:"Lock is securely included", isStateChange: true)
}

/**
 * Responsible for parsing DoorLockOperationReport command
 *
 * @param cmd: The DoorLockOperationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(DoorLockOperationReport cmd) {
    log.trace "[DTH] Executing 'zwaveEvent(DoorLockOperationReport)' with cmd = $cmd"
	def result = []

	unschedule("followupStateCheck")
	unschedule("stateCheck")

    if (isAugustLock()) { // August lock pro has a firmware bug and reports a doorLockMode of 254, ignore it (zw:Fs type:4003 mfr:033F prod:0001 model:0001 ver:0.38 zwv:4.61 lib:03 cc:5E,55,98,9F sec:86,72,5A,73,80,62,85,8E,59,6C,7A role:07 ff:8300 ui:8300)
        if (cmd.doorLockMode == 0xFE) {
            log.trace "August lock firmware bug, ignoring 0xFE door lock report"
            return
        }
    }

	// DoorLockOperationReport is called when trying to read the lock state or when the lock is locked/unlocked from the DTH or the smart app
	def map = [ name: "lock" ]
	map.data = [ lockName: device.displayName ]
	if (cmd.doorLockMode == 0xFF) {
		map.value = "locked"
		map.descriptionText = "Locked"
	} else if (cmd.doorLockMode >= 0x40) {
		map.value = "unknown"
		map.descriptionText = "Unknown state"
	} else if (cmd.doorLockMode == 0x01) {
		map.value = "unlocked with timeout"
		map.descriptionText = "Unlocked with timeout"
	}  else {
		map.value = "unlocked"
		map.descriptionText = "Unlocked"
		if (state.assoc != zwaveHubNodeId) {
			result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
			result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
			result << response(secure(zwave.associationV1.associationGet(groupingIdentifier:1)))
		}
	}

    // Some locks supports reporting door state, see Z-Wave specs check bit 0 for door state
    if (isIDLock() || isAugustLock() || isKeyWeLock()) { // IDLock, August, KeyWe
        if ((cmd.doorCondition & 1) == 0) { // Door open
            setState("open", "$device.displayName is open")
        } else if ((cmd.doorCondition & 1) == 1) { // Door closed
            setState("closed", "$device.displayName is closed")
        }
    }

	if (generatesDoorLockOperationReportBeforeAlarmReport()) {
		// we're expecting lock events to come after notification events, but for specific yale locks they come out of order
		runIn(3, "delayLockEvent", [data: [map: map]])
        return [:]
	} else {
		return result ? [createEvent(map), *result] : createEvent(map)
	}
}

def delayLockEvent(data) {
	log.debug "Sending cached lock operation: $data.map"
	sendEvent(data.map)
}

/**
 * Responsible for parsing AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport)' with cmd = $cmd"
	def result = []
	
	if (cmd.zwaveAlarmType == 6) {
		result = handleAccessAlarmReport(cmd)
	} else if (cmd.zwaveAlarmType == 7) {
		result = handleBurglarAlarmReport(cmd)
	} else if(cmd.zwaveAlarmType == 8) {
		result = handleBatteryAlarmReport(cmd)
	} else if(cmd.zwaveAlarmType == 0xA) {
		result = handleEmergencyAlarmReport(cmd)
	} else {
		result = handleAlarmReportUsingAlarmType(cmd)
	}
		
	result = result ?: null
	log.debug "[DTH] zwaveEvent(physicalgraph.zwave.commands.alarmv2.AlarmReport) returning with result = $result"
	result
}

/**
 * Responsible for handling Access AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleAccessAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleAccessAlarmReport' with cmd = $cmd"
	def result = []
	def map = null
	def codeID, changeType, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
	if (1 <= cmd.zwaveAlarmEvent && cmd.zwaveAlarmEvent < 10) {
		map = [ name: "lock", value: (cmd.zwaveAlarmEvent & 1) ? "locked" : "unlocked" ]
	}
	switch(cmd.zwaveAlarmEvent) {
		case 1: // Manually locked
            map.descriptionText = (cmd.alarmLevel == 2) ? "Locked via keypad" : "Locked manually"
            map.data = [ method: (cmd.alarmLevel == 2) ? "keypad" : "manual" ] // Yale Assure Deadbolt has alarmLevel as 2 for external keypad lock and 1 for internal knob lock
			break
		case 2: // Manually unlocked
			map.descriptionText = "Unlocked manually"
			map.data = [ method: "manual" ]
			break
		case 3: // Locked by command, Danalock/Yale RF Lock
			map.descriptionText = "Locked"
			map.data = [ method: "command" ]
			break
		case 4: // Unlocked by command, RF Unlock
			if (cmd.numberOfEventParameters) { // IDLock RFID
				codeID = readCodeSlotId(cmd)
            }            
        	if (codeID != null) {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, method: "rfid" ]
            } else { // Yale and Danalock RF
				map.descriptionText = "Unlocked"
				map.data = [ method: "command" ]
            }
			break
		case 5: // Locked with keypad
			// Schlage locked from outside via keypad (alarmLevel=0 for no code lock and leave, alarmLevel=1 for with code)
			if (cmd.numberOfEventParameters || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				codeID = (isKwiksetLock() || isSchlageLock()) ? (codeID ?: null) : codeID // Schlage/Kwikset locks report 0 for outside button/one touch lock (don't use 0 as it's considered Master Code, report null for Schlage/Kwikset)
			}
			if (codeID != null) {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Locked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else { 
				// locked by pressing the Schlage button or August lock keypad
				map.descriptionText = "Locked via keypad"
				map.data = [ method: "keypad" ]
			}
			break
		case 6: // Unlocked with keypad
			// Schlage locked from outside via keypad (alarmLevel=0 for no code lock and leave, alarmLevel=1 for with code)
			if (cmd.numberOfEventParameters || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				codeID = (isKwiksetLock() || isSchlageLock()) ? (codeID ?: null) : codeID // Schlage/Kwikset locks report 0 for outside button/one touch lock (don't use 0 as it's considered Master Code, report null for Schlage/Kwikset)
			}
			if (codeID != null) {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else if (isIDLock()) { // IDLock null is used for RF command because it reports it here instead of using ZWave Alarm Event 4
				map.descriptionText = "Unlocked"
				map.data = [ method: "command" ]
			} else { // Schalge/Kwikset/IDLock Outside one touch lock and August lock via keypad
				map.descriptionText = "Unlocked via keypad"
				map.data = [ method: "keypad" ]
			}
            // Note: Popp Keypad only sends an unlock event, so we need to send a lock event after a few seconds
			if(isPoppKeypad() && ("0005" == zwaveInfo.prod && "0002" == zwaveInfo.model)) {
            	log.trace "Popp keypad, resetting unlocked to locked notification in 3 seconds"
				runIn(3, reLocked)
            }
			break
		case 7:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "manual" ]
			break
		case 8: // RF Jammed
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "command" ]
			break
		case 9: // Auto locked
			map = [ name: "lock", value: "locked", data: [ method: "auto" ] ]
			map.descriptionText = "Auto locked"
			break
		case 0xA: // Auto locked jammed
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "auto" ]
			break
		case 0xB: // Jammed
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			break
		case 0xC: // All user codes deleted
			result = allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true ]
			map.data = [notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"]
			result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
			break
		case 0xD: // User code deleted
			if (cmd.numberOfEventParameters || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				if (lockCodes[codeID.toString()]) {
					codeName = getCodeName(lockCodes, codeID)
					map = [ name: "codeChanged", value: "$codeID deleted", isStateChange: true ]
					map.descriptionText = "Deleted \"$codeName\""
					map.data = [ codeName: codeName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
					result << codeDeletedEvent(lockCodes, codeID)
				}
			}
			break
		case 0xE: // Master or user code changed/set
			if (cmd.numberOfEventParameters || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				if(codeID == 0 && isKwiksetLock()) {
					//Ignoring this AlarmReport as Kwikset reports codeID 0 when all slots are full and user tries to set another lock code manually
					//Kwikset locks don't send AlarmReport when Master code is set
					log.trace "Ignoring this alarm report in case of Kwikset locks"
					break
				}
				codeName = getCodeNameFromState(lockCodes, codeID)
				changeType = getChangeType(lockCodes, codeID)
				map = [ name: "codeChanged", value: "$codeID $changeType",  descriptionText: "${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
				map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
				if(!isMasterCode(codeID)) {
					result << codeSetEvent(lockCodes, codeID, codeName)
				} else {
					map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
					map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
				}
			}
			break
		case 0xF: // Duplicate Pin-code error
			if (cmd.numberOfEventParameters || cmd.alarmLevel) {
				codeID = readCodeSlotId(cmd)
				clearStateForSlot(codeID)
				map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is duplicate and not added",
					isStateChange: true, data: [isCodeDuplicate: true] ]
			}
			break
		case 0x10: // Tamper Alarm
		case 0x13:
			map = [ name: "invalidCode", value: "detected", descriptionText: "Keypad attempts exceed code entry limit", isStateChange: true, displayed: true ]
			break
		case 0x14: // IDLock invalid RFID code (5 bytes long) and Danalock invalid RF code
			map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid code ${cmd.eventParameter?.join("")}", isStateChange: true, displayed: true ]
			break
		case 0x11: // Keypad busy
			map = [ descriptionText: "Keypad is busy" ]
			break
		case 0x12: // Master code changed
			codeName = getCodeNameFromState(lockCodes, 0)
			map = [ name: "codeChanged", value: "0 set", descriptionText: "${getStatusForDescription('set')} \"$codeName\"", isStateChange: true ]
			map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}" ]
			break
		case 0x16: // DPS Open
			setState("open", "$device.displayName is open")
			map = [ descriptionText: "$device.displayName: DPS Open", displayed: false ]
			break
		case 0x17: // DPS Closed
			setState("closed", "$device.displayName is closed")
			map = [ descriptionText: "$device.displayName: DPS Closed", displayed: false ]
			break
		case 0x18: // KeyWe manual unlock
			map = [ name: "lock", value: "unlocked", data: [ method: "manual" ] ]
			map.descriptionText = "Unlocked manually"
			break
		case 0x19: // KeyWe manual lock
			map = [ name: "lock", value: "locked", data: [ method: "manual" ] ]
			map.descriptionText = "Locked manually"
			break
        case 0xFE:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	
	if (map) {
		if (map.data) {
			map.data.lockName = deviceName
		} else {
			map.data = [ lockName: deviceName ]
		}
		result << createEvent(map)
	}
	result = result.flatten()
	result
}

/**
 * Responsible for handling Burglar AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleBurglarAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleBurglarAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	
	def map = [ name: "tamper", value: "detected", isStateChange: true ]
	map.data = [ lockName: deviceName ]
	switch (cmd.zwaveAlarmEvent) {
		case 0:
			map.value = "clear"
			map.descriptionText = "Tamper alert cleared"
			break
		case 1:
		case 2: // Forced mode Schlage (no reset sent)
			activateMotion("$device.displayName: Door tampering activity detected")
			runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			map.descriptionText = "Intrusion attempt detected"
			break
        case 8: // Samsung motion detection
		case 3:
			activateMotion("$device.displayName: Door tampering activity detected")
			runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			map.descriptionText = "Covering removed"
			break
		case 4:
			map = [ name: "invalidCode", value: "detected", descriptionText: "Invalid code", isStateChange: true, displayed: true ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	
	result << createEvent(map)
	result
}

/**
 * Responsible for handling Battery AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 */
private def handleBatteryAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleBatteryAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	def map = null
	switch(cmd.zwaveAlarmEvent) {
		case 0x0A:
			map = [ name: "battery", value: 1, descriptionText: "Battery level critical", displayed: true, data: [ lockName: deviceName ] ]
			break
		case 0x0B:
			map = [ name: "battery", value: 0, descriptionText: "Battery too low to operate lock", isStateChange: true, displayed: true, data: [ lockName: deviceName ] ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	result << createEvent(map)
	result
}

/**
 * Responsible for handling Emergency AlarmReport command
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 */
private def handleEmergencyAlarmReport(cmd) {
	log.trace "[DTH] Executing 'handleEmergencyAlarmReport' with cmd = $cmd"
	def result = []
	def deviceName = device.displayName
	def map = null
	switch(cmd.zwaveAlarmEvent) {
		case 0x01:
			map = [ descriptionText: "Contact police" ]
			break
		case 0x02:
			map = [ descriptionText: "Contact fire service" ]
			break
		default:
			// delegating it to handleAlarmReportUsingAlarmType
			return handleAlarmReportUsingAlarmType(cmd)
	}
	result << createEvent(map)
	result
}

/**
 * Responsible for handling AlarmReport commands which are ignored by Access & Burglar handlers
 *
 * @param cmd: The AlarmReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
private def handleAlarmReportUsingAlarmType(cmd) {
	log.trace "[DTH] Executing 'handleAlarmReportUsingAlarmType' with cmd = $cmd"
	def result = []
	def map = null
	def codeID, lockCodes, codeName
	def deviceName = device.displayName
	lockCodes = loadLockCodes()
	switch(cmd.alarmType) {
		case 10: // IDLock fire sensor
			if (cmd.zwaveAlarmEvent == 2) {
				activateSmoke("Detected Fire")
				runIn(60, deactivateSmoke)
			}
			break
		case 9: // Yale
		case 17: // Kwikset
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
            map.data = [ method: "keypad" ]
			break
		case 16: // Note: for levers this means it's unlocked, for non-motorized deadbolt, it's just unsecured and might not get unlocked
            // Note: Schlage FE599 non motorized deadbolt sends 16 and motorized deadbolts like BE469 send 19. However with non motorized deadbolts it only unsecures the handles and not unlocks, so we need to send a lock event after a few seconds only if it was currently locked
			if(isSchlageLock() && ("634B" == zwaveInfo.prod && "504C" == zwaveInfo.model) && (device.currentValue("lock") == "locked")) {
            	log.trace "Non motorized bolt, resetting unlocked to locked notification in 3 seconds"
				runIn(3, reLocked) // The bolt resecures after 3 seconds, send the locked event notification
            }
		case 19: // Unlocked with keypad
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel != null) {
				codeID = readCodeSlotId(cmd)
				codeName = getCodeName(lockCodes, codeID)
                map.isStateChange = true // Fix for Schlage FE599, mark state changed since it can be unlocked multiple times
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad" ]
			} else { 
				map.descriptionText = "Unlocked via keypad"
				map.data = [ method: "keypad" ]
			}
			break
		case 18: // Locked with keypad
			codeID = readCodeSlotId(cmd)
			map = [ name: "lock", value: "locked" ]
			// Kwikset and Schlage lock reporting code id as 0 when locked using the lock keypad button
			if ((isKwiksetLock() || isSchlageLock()) && codeID == 0) {
				map.descriptionText = "Locked via keypad"
				map.data = [ method: "keypad" ]
			} else {
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Locked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "keypad" ]
			}
			break
		case 21: // Manually locked, One touch locked via keypad (Yale) alarmLevel 2, using key/knob alarmLevel 1 (Kwikset)
			map = [ name: "lock", value: "locked", data: [ method: (cmd.alarmLevel == 2) ? "keypad" : "manual" ] ]
			map.descriptionText = (cmd.alarmLevel == 2) ? "Locked via keypad" : "Locked manually"
			break
		case 22: // Manually unlocked
			map = [ name: "lock", value: "unlocked", data: [ method: "manual" ] ]
			map.descriptionText = "Unlocked manually"
			break
		case 23:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "command" ]
			break
		case 24: // Locked by command (Kwikset/Yale)
			map = [ name: "lock", value: "locked", data: [ method: "command" ] ]
			map.descriptionText = "Locked"
			break
		case 25: // Unlocked by command (Kwikset/Yale)
			map = [ name: "lock", value: "unlocked", data: [ method: "command" ] ]
			map.descriptionText = "Unlocked"
			break
		case 26:
			map = [ name: "lock", value: "unknown", descriptionText: "Unknown state" ]
			map.data = [ method: "auto" ]
			break
		case 27: // Auto locked
			map = [ name: "lock", value: "locked", data: [ method: "auto" ] ]
			map.descriptionText = "Auto locked"
			break
		case 32: // All user codes deleted
			result = allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true ]
			map.data = [notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"]
			result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
			break
		case 33: // User code deleted
			codeID = readCodeSlotId(cmd)
			if (lockCodes[codeID.toString()]) {
				codeName = getCodeName(lockCodes, codeID)
				map = [ name: "codeChanged", value: "$codeID deleted", isStateChange: true ]
				map.descriptionText = "Deleted \"$codeName\""
				map.data = [ codeName: codeName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
				result << codeDeletedEvent(lockCodes, codeID)
			}
			break
		case 38: // Yale Non Access User (programmed but does not operate lock), alarmLevel represents user slot no
			map = [ name: "invalidCode", value: "detected", descriptionText: "A Non Access User $cmd.alarmLevel was entered at the lock", isStateChange: true, displayed: true ]
			break
		case 43: // Yale DPS
			if (cmd.alarmLevel == 2) {
				setState("open", "$device.displayName is open")
				map = [ descriptionText: "DPS Open", displayed: false ]
			}
			break
		case 13:
		case 112: // Master or user code changed/set
			codeID = readCodeSlotId(cmd)
			if(codeID == 0 && isKwiksetLock()) {
				//Ignoring this AlarmReport as Kwikset reports codeID 0 when all slots are full and user tries to set another lock code manually
				//Kwikset locks don't send AlarmReport when Master code is set
				log.trace "Ignoring this alarm report in case of Kwikset locks"
				break
			}
			codeName = getCodeNameFromState(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)
			map = [ name: "codeChanged", value: "$codeID $changeType", descriptionText:
				"${getStatusForDescription(changeType)} \"$codeName\"", isStateChange: true ]
			map.data = [ codeName: codeName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
			if(!isMasterCode(codeID)) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
				map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
			}
			break
		case 34:
		case 113: // Duplicate Pin-code error
			codeID = readCodeSlotId(cmd)
			clearStateForSlot(codeID)
			map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is duplicate and not added",
				isStateChange: true, data: [isCodeDuplicate: true] ]
			break
		case 130:  // Batteries replaced (Yale YRD)
			map = [ descriptionText: "Batteries replaced", isStateChange: true ]
			break
		case 131: // Disabled user entered at keypad
			map = [ name: "invalidCode", value: "detected", descriptionText: "Disabled code ${cmd.alarmLevel} was entered", isStateChange: true, displayed: true ]
			break
		case 132: // Yale Out of schedule user (valid)
			map = [ name: "invalidCode", value: "detected", descriptionText: "Out of Schedule code $cmd.alarmLevel was entered", isStateChange: true, displayed: true ]
			break
		case 144: // Yale unlocked using RFID tag
			map = [ name: "lock", value: "unlocked" ]
			if (cmd.alarmLevel > 0) {
                codeID = readCodeSlotId(cmd)
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Unlocked by \"$codeName\""
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName, method: "rfid" ]
			} else {
				map.descriptionText = "Unlocked manually"
				map.data = [ method: "rfid" ]
			}
			break
		case 96: // Schlage FE599 (alarmType 96, alarmLevel 255)
		case 161: // Tamper Alarm
			if (cmd.alarmLevel == 2) {
				map = [ name: "tamper", value: "detected", descriptionText: "Front escutcheon removed", isStateChange: true ]
				activateMotion("$device.displayName: Door tampering activity detected")
				runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else if (cmd.alarmLevel == 1) {
				map = [ name: "invalidCode", value: "detected", descriptionText: "Keypad attempts exceed code entry limit", isStateChange: true, displayed: true ]
			} else if (cmd.alarmLevel == 3) {
				map = [ name: "tamper", value: "detected", descriptionText: "Handle open detected", isStateChange: true, displayed: true ] // Yale 6th gen Keyfree lock Handle Alarm
				activateMotion("$device.displayName: Door tampering activity detected")
				runIn(60, deactivateMotion) // Clear motion and tamper after 60 seconds, since tamper clear is never sent by a lock
			} else {
				map = [ name: "invalidCode", value: "detected", descriptionText: "Detected failed user code attempt", isStateChange: true, displayed: true ]
			}
			break
		case 162: // Kwikset - User attempt outside schedule
			map = [ name: "invalidCode", value: "detected", isStateChange: true, displayed: true ]
			if (cmd.alarmLevel != null) {
				codeID = readCodeSlotId(cmd)
				codeName = getCodeName(lockCodes, codeID)
				map.descriptionText = "Keypad attempt by \"$codeName\" outside scheduled time"
				map.data = [ codeId: codeID as String, usedCode: codeID, codeName: codeName ]
			} else { 
                map.descriptionText = "Keypad attempt outside scheduled time"
			}
			break
		case 167: // Low Battery Alarm
			if (!state.lastbatt || now() - state.lastbatt > 12*60*60*1000) {
				map = [ descriptionText: "Battery low", isStateChange: true ]
				result << response(getBatteryState())
			} else {
				map = [ name: "battery", value: device.currentValue("battery"), descriptionText: "Battery low", isStateChange: true ]
			}
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 168: // Critical Battery Alarms
			map = [ name: "battery", value: 1, descriptionText: "Battery level critical", displayed: true ]
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 169: // Battery too low to operate
			map = [ name: "battery", value: 0, descriptionText: "Battery too low to operate lock", isStateChange: true, displayed: true ]
			runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register			
			break
		case 176: // Yale Mobile Access, unlocked via Bluetooth
			map = [ name: "lock", value: "unlocked" ]
			map.descriptionText = "Unlocked"
			map.data = [ method: "bluetooth" ]
			break
        case 178: // Yale configuration params updated via Mobile
        	map = [ descriptionText: "Configuration params update via Mobile", displayed: false ]
        	break
		default:
			map = [ displayed: false, descriptionText: "Alarm event ${cmd.alarmType} level ${cmd.alarmLevel}" ]
			break
	}
	
	if (map) {
		if (map.data) {
			map.data.lockName = deviceName
		} else {
			map.data = [ lockName: deviceName ]
		}
		result << createEvent(map)
	}
	result = result.flatten()
	result
}

/**
 * Responsible for parsing UserCodeReport command
 *
 * @param cmd: The UserCodeReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(UserCodeReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(UserCodeReport)' with userIdentifier: ${correctLockCode(cmd.userIdentifier)} and status: ${cmd.userIdStatus}\nRaw:${cmd}"
	def result = []
	// cmd.userIdentifier seems to be an int primitive type
	def codeID = correctLockCode(cmd.userIdentifier).toString()
	def lockCodes = loadLockCodes()
	def map = [ name: "codeChanged", isStateChange: true ]
	def deviceName = device.displayName
	def userIdStatus = cmd.userIdStatus
	
	if (userIdStatus == UserCodeReport.USER_ID_STATUS_OCCUPIED ||
				(userIdStatus == UserCodeReport.USER_ID_STATUS_STATUS_NOT_AVAILABLE && cmd.user)) {
				
		def codeName
		
		// Schlage locks sends a blank/empty code during code creation/updation where as it sends "**********" during scanning
		// Some Schlage locks send "**********" during code creation also. The state check will work for them
		if ((!cmd.code || state["setname$codeID"]) && isSchlageLock()) {
			// this will be executed when the user tries to create/update a user code through the
			// smart app or manually on the lock. This is specific to Schlage locks.
			log.trace "[DTH] User code creation successful for Schlage lock"
			codeName = getCodeNameFromState(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)

			map.value = "$codeID $changeType"
			map.isStateChange = true
			map.descriptionText = "${getStatusForDescription(changeType)} \"$codeName\""
			map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "${getStatusForDescription(changeType)} \"$codeName\" in $deviceName at ${location.name}" ]
			if(!isMasterCode(codeID)) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.descriptionText = "${getStatusForDescription('set')} \"$codeName\""
				map.data.notificationText = "${getStatusForDescription('set')} \"$codeName\" in $deviceName at ${location.name}"
				map.data.lockName = deviceName
			}
		} else {
			// We'll land here during scanning of codes
			codeName = getCodeName(lockCodes, codeID)
			def changeType = getChangeType(lockCodes, codeID)
			if (!lockCodes[codeID]) {
				result << codeSetEvent(lockCodes, codeID, codeName)
			} else {
				map.displayed = false
			}
			map.value = "$codeID $changeType"
			map.descriptionText = "${getStatusForDescription(changeType)} \"$codeName\""
			map.data = [ codeName: codeName, lockName: deviceName ]
		}
	} else if(userIdStatus == 254 && isSchlageLock()) {
		// This is code creation/updation error for Schlage locks.
		// It should be OK to mark this as duplicate pin code error since in case the batteries are down, or lock is not in range,
		// or wireless interference is there, the UserCodeReport will anyway not be received.
		map = [ name: "codeChanged", value: "$codeID failed", descriptionText: "User code is not added", isStateChange: true,
			data: [ lockName: deviceName, isCodeDuplicate: true] ]
	} else {
		// We are using userIdStatus here because codeID = 0 is reported when user tries to set programming code as the user code
		if (codeID == "0" && userIdStatus == UserCodeReport.USER_ID_STATUS_AVAILABLE_NOT_SET && isSchlageLock()) {
			// all codes deleted for Schlage locks
			log.trace "[DTH] All user codes deleted for Schlage lock"
			result << allCodesDeletedEvent()
			map = [ name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true,
				data: [ lockName: deviceName, notify: true,
					notificationText: "Deleted all user codes in $deviceName at ${location.name}"] ]
			lockCodes = [:]
			result << lockCodesEvent(lockCodes)
		} else {
			// code is not set
			if (lockCodes[codeID]) {
				def codeName = getCodeName(lockCodes, codeID)
				map.value = "$codeID deleted"
				map.descriptionText = "Deleted \"$codeName\""
				map.data = [ codeName: codeName, lockName: deviceName, notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ]
				result << codeDeletedEvent(lockCodes, codeID)
			} else {
				map.value = "$codeID unset"
				map.displayed = false
				map.data = [ lockName: deviceName ]
			}
		}
	}
	
	clearStateForSlot(codeID)
	result << createEvent(map)
	
	if (codeID.toInteger() == state.checkCode) {  // reloadAllCodes() was called, keep requesting the codes in order
		if (state.checkCode + 1 > state.codes || state.checkCode >= 8) {
			state.remove("checkCode")  // done
			state["checkCode"] = null
			sendEvent(name: "scanCodes", value: "Complete", descriptionText: "Code scan completed", displayed: false)
		} else {
			state.checkCode = state.checkCode + 1  // get next
			result << response(requestCode(state.checkCode))
		}
	}
	if (codeID == state.pollCode) {
		if (state.pollCode + 1 > state.codes || state.pollCode >= 15) {
			state.remove("pollCode")  // done
			state["pollCode"] = null
		} else {
			state.pollCode = state.pollCode + 1
		}
	}

	result = result.flatten()
	result
}

/**
 * Responsible for parsing UsersNumberReport command
 *
 * @param cmd: The UsersNumberReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(UsersNumberReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(UsersNumberReport)' with cmd = $cmd"
	def result = [createEvent(name: "maxCodes", value: cmd.supportedUsers, displayed: false)]
	state.codes = cmd.supportedUsers
	if (state.checkCode) {
		if (state.checkCode <= cmd.supportedUsers) {
			result << response(requestCode(state.checkCode))
		} else {
			state.remove("checkCode")
			state["checkCode"] = null
		}
	}
	result
}

/**
 * Responsible for parsing AssociationReport command
 *
 * @param cmd: The AssociationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.associationv2.AssociationReport)' with cmd = $cmd"
	def result = []
	if (cmd.nodeId.any { it == zwaveHubNodeId }) {
		state.remove("associationQuery")
		state["associationQuery"] = null
		result << createEvent(descriptionText: "Is associated")
		state.assoc = zwaveHubNodeId
		if (cmd.groupingIdentifier == 2) {
			result << response(zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		}
	} else if (cmd.groupingIdentifier == 1) {
		result << response(secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId)))
	} else if (cmd.groupingIdentifier == 2) {
		result << response(zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId))
	}
	result
}

/**
 * Responsible for parsing TimeGet command
 *
 * @param cmd: The TimeGet command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.timev1.TimeGet)' with cmd = $cmd"
	def result = []
	def now = new Date().toCalendar()
	if(location.timeZone) now.timeZone = location.timeZone
	result << createEvent(descriptionText: "Requested time update", displayed: false)
	result << response(secure(zwave.timeV1.timeReport(
		hourLocalTime: now.get(Calendar.HOUR_OF_DAY),
		minuteLocalTime: now.get(Calendar.MINUTE),
		secondLocalTime: now.get(Calendar.SECOND)))
	)
	result
}

/**
 * Responsible for parsing BasicSet command
 *
 * @param cmd: The BasicSet command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet)' with cmd = $cmd"
	// The old Schlage locks use group 1 for basic control - we don't want that, so unsubscribe from group 1
	def result = [ createEvent(name: "lock", value: cmd.value ? "unlocked" : "locked") ]
	def cmds = [
			zwave.associationV1.associationRemove(groupingIdentifier:1, nodeId:zwaveHubNodeId).format(),
			"delay 1200",
			zwave.associationV1.associationGet(groupingIdentifier:2).format()
	]
	[result, response(cmds)]
}

/**
 * Responsible for parsing BatteryReport command
 *
 * @param cmd: The BatteryReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport)' with cmd = $cmd"
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "Has a low battery"
	} else {
		map.value = cmd.batteryLevel
		map.descriptionText = "Battery is at ${cmd.batteryLevel}%"
	}
	state.lastbatt = now()
	runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
	log.info "Battery level $map.value%"
	createEvent(map) 
}

/**
 * Responsible for parsing ManufacturerSpecificReport command
 *
 * @param cmd: The ManufacturerSpecificReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport)' with cmd = $cmd"
	def result = []
	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	updateDataValue("MSR", msr)
	result << createEvent(descriptionText: "MSR: $msr", isStateChange: false)
	result
}

/**
 * Responsible for parsing VersionReport command
 *
 * @param cmd: The VersionReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.versionv1.VersionReport)' with cmd = $cmd"
	def fw = "${cmd.applicationVersion}.${cmd.applicationSubVersion}"
	updateDataValue("fw", fw)
	if (getDataValue("MSR") == "003B-6341-5044") {
		updateDataValue("ver", "${cmd.applicationVersion >> 4}.${cmd.applicationVersion & 0xF}")
	}
	def text = "${device.displayName}: firmware version: $fw, Z-Wave version: ${cmd.zWaveProtocolVersion}.${cmd.zWaveProtocolSubVersion}"
	createEvent(descriptionText: text, isStateChange: false)
}

/**
 * Responsible for parsing ApplicationBusy command
 *
 * @param cmd: The ApplicationBusy command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationBusy)' with cmd = $cmd"
	def msg = cmd.status == 0 ? "try again later" :
			  cmd.status == 1 ? "try again in ${cmd.waitTime} seconds" :
			  cmd.status == 2 ? "request queued" : "sorry"
	createEvent(displayed: true, descriptionText: "Is busy, $msg")
}

/**
 * Responsible for parsing ApplicationRejectedRequest command
 *
 * @param cmd: The ApplicationRejectedRequest command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest cmd) {
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.commands.applicationstatusv1.ApplicationRejectedRequest)' with cmd = $cmd"
	createEvent(displayed: true, descriptionText: "Rejected the last request")
}

/**
 * Responsible for parsing zwave command
 *
 * @param cmd: The zwave command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Ignoring command from $device.displayName: $cmd"
	log.trace "[DTH] Executing 'zwaveEvent(physicalgraph.zwave.Command)' with cmd = $cmd"
	createEvent(displayed: false, descriptionText: "$cmd")
}

/**
 * Executes lock and then check command with a delay on a lock
 */
def lockAndCheck(doorLockMode) {
	secureSequence([
		zwave.doorLockV1.doorLockOperationSet(doorLockMode: doorLockMode),
		zwave.doorLockV1.doorLockOperationGet()
	], 4200)
}

/**
 * Executes lock command on a lock
 */
def lock() {
	log.trace "[DTH] Executing lock() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_SECURED)
}

/**
 * Executes unlock command on a lock
 */
def unlock() {
	log.trace "[DTH] Executing unlock() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED)
}

/**
 * Executes unlock with timeout command on a lock
 */
def unlockWithTimeout() {
	log.trace "[DTH] Executing unlockWithTimeout() for device ${device.displayName}"
	lockAndCheck(DoorLockOperationSet.DOOR_LOCK_MODE_DOOR_UNSECURED_WITH_TIMEOUT)
}

/**
 * PING is used by Device-Watch in attempt to reach the Device
 */
def ping() {
	log.trace "[DTH] Executing ping() for device ${device.displayName}"
	runIn(30, followupStateCheck)
	secure(zwave.doorLockV1.doorLockOperationGet())
}

/**
 * Checks the door lock state. Also, schedules checking of door lock state every one hour.
 */
def followupStateCheck() {
	runEvery1Hour(stateCheck)
	stateCheck()
}

/**
 * Checks the door lock state
 */
def stateCheck() {
	sendHubCommand(new physicalgraph.device.HubAction(secure(zwave.doorLockV1.doorLockOperationGet())))
}

/**
 * Called when the user taps on the refresh button
 */
def refresh() {
    log.debug "Refresh called, Device MSR is $state.MSR"
    identifyLockModel()

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("checkInterval")) { // If the user updated the device handler
        sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    }
    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

    def cmds = []

	if (!state.associationQuery) {
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()  // old Schlage locks use group 2 and don't secure the Association CC
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = now()
	} else if (now() - state.associationQuery.toLong() > 9000) {
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = now()
	}

    if (!state.MSR || !state.configured) { // If we don't have a MSR or we refreshed the settings, first get it
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format() // Some locks only support non secure responses (Schlage)
        cmds << secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet()) // Some locks only support secure responses (August Pro)
    }

    if (!state.configured) {
        cmds << configureLock() // Configure lock settings
        state.configured = true // We're done here
    }

    if (!device.currentValue("scanCodes")) { // Start reloading codes only if initialized for the first time
        cmds << reloadAllCodes()
    }
	if (!device.currentValue("maxCodes")) {
		state.pollCode = 1
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else if (state.pollCode && state.pollCode <= state.codes) {
		cmds << requestCode(state.pollCode)
	}
	log.trace "Current user pin code length ${device.currentValue("codeLength")}"
    cmds << getCodeLength() // Pin code length, Check for changes

    cmds << getAlarmLevel() // Alarm Level
    cmds << getKeypadState() // Keypad
    cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
    cmds << getAutolockState() // Auto Lock
    cmds << getOneTouchLockState() // One touch lock
    cmds << getAudioState() // Audio/Beeper

    cmds << secure(zwave.doorLockV1.doorLockOperationGet())
    cmds << getBatteryState() // Battery

    if (!state.fw) {
        cmds << zwave.versionV1.versionGet().format()
    }
    
    state.lastLockDetailsQuery = now()

    delayBetween(cmds, 4200)
}

def scheduledPoll() {
    sendHubCommand(response(poll()).toHubAction()) // Send command since this can be called from a schedule
}

/**
 * Called by the Smart Things platform in case Polling capability is added to the device type
 */
def poll() {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Universal Z-Wave Lock Device Handler"]) // Save DH Name for parent app

    if (!device.currentValue("checkInterval")) { // If the user updated the device handler
        sendEvent(name: "checkInterval", value: 1 * 60 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID, offlinePingable: "1"])
    }

    if (!device.currentValue("motion")?.trim() || !device.currentValue("tamper")?.trim()) { // If the tamper/motion sensor state isn't defined then lets define it to report it correctly in SHM
        resetMotion()
    }
    if (!device.currentValue("smoke")?.trim()) { // If the smoke/fire sensor state isn't defined then lets define it to report it correctly in SHM
        resetSmoke()
    }
    if (!device.currentValue("contact")?.trim()) { // If the door closed sensor state isn't defined then lets define it to report it correctly in SHM
        resetState()
    }

    def cmds = []

    log.debug "Poll called, Device MSR is $state.MSR"
    if (!state.MSR) { // If we don't have a MSR, first get it (and wait for it to complete)
        log.debug "Getting Device MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet().format() // Some locks only support non secure responses (Schlage)
        cmds << secure(zwave.manufacturerSpecificV2.manufacturerSpecificGet()) // Some locks only support secure responses (August Pro)
    }

    // Only check lock state if it changed recently or we haven't had an update in an hour
    def latest = device.currentState("lock")?.date?.time
    if (state.assoc != zwaveHubNodeId && secondsPast(state.associationQuery, 19 * 60)) {
		cmds << zwave.associationV1.associationSet(groupingIdentifier:2, nodeId:zwaveHubNodeId).format()
		cmds << secure(zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId))
		cmds << zwave.associationV1.associationGet(groupingIdentifier:2).format()
		cmds << secure(zwave.associationV1.associationGet(groupingIdentifier:1))
		state.associationQuery = now()
    } else if (!latest || !state.lastPoll || !secondsPast(latest, 6 * 60) || secondsPast(state.lastPoll, 55 * 60)) {
        if (!device.currentValue("scanCodes")) { // Start reloading codes only if initialized for the first time
            cmds << reloadAllCodes()
        }
		if (!device.currentValue("maxCodes")) {
			state.pollCode = 1
			cmds << secure(zwave.userCodeV1.usersNumberGet())
		} else if (state.pollCode && state.pollCode <= state.codes) {
			cmds << requestCode(state.pollCode)
		}
		log.trace "Current user pin code length ${device.currentValue("codeLength")}"
        if (device.currentValue("codeLength") != 0) { // If we haven't checked for it (null) or if it was returned by the lock, check for changes
            cmds << getCodeLength() // Pin code length
        }
        cmds << secure(zwave.doorLockV1.doorLockOperationGet())
        cmds << getAlarmLevel() // Alarm Level
        cmds << getKeypadState() // Keypad
        cmds << getSensitiveLevel() // Alarm Sensitivity Level (give alarm 10 seconds to update before getting sensitive)
        cmds << getAutolockState() // Auto Lock
        cmds << getOneTouchLockState() // One touch lock
        cmds << getAudioState() // Audio/Beeper
        state.lastPoll = now()
    }
	if (!state.fw) {
		cmds << zwave.versionV1.versionGet().format()
	}
    if (!state.lastbatt || secondsPast(state.lastbatt, 24*60*60)) {
        cmds << getBatteryState()
        state.lastbatt = now()  //inside-214
    }
    if (cmds) {
        delayBetween(cmds, 4200)
    } else {
        // workaround to keep polling from stopping due to lack of activity
        log.trace "Poll called again to soon, skipping poll to save battery"
        sendEvent(descriptionText: "skipping poll", isStateChange: true, displayed: false)
        null
    }
}

/**
 * Returns the command for user code get
 *
 * @param codeID: The code slot number
 *
 * @return The command for user code get
 */
def requestCode(codeID) {
    if (isIDLock() && !isIDLock101()) { // IDLock 150, starting 60 are keypad PIN users (user 1 is master and user 2 is service (remotely programmable) but we ignore for IDLock150)
        codeID = codeID + 59 // First keypad user is slot  for ST
    }
	secure(zwave.userCodeV1.userCodeGet(userIdentifier: codeID))
}

/**
 * API endpoint for server smart app to populate the attributes. Called only when the attributes are not populated.
 *
 * @return The command(s) fired for reading attributes
 */
def reloadAllCodes() {
	log.trace "[DTH] Executing 'reloadAllCodes()' by ${device.displayName}"
	sendEvent(name: "scanCodes", value: "Scanning", descriptionText: "Code scan in progress", displayed: false)
	def lockCodes = loadLockCodes()
	sendEvent(lockCodesEvent(lockCodes))
	state.checkCode = state.checkCode ?: 1

	def cmds = []
	// Not calling validateAttributes() here because userNumberGet command will be added twice
	if(!device.currentValue("codeLength")) {
		cmds << getCodeLength()
	}
	if (!state.codes) {
		// BUG: There might be a bug where Schlage does not return the below number of codes
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	} else {
		sendEvent(name: "maxCodes", value: state.codes, displayed: false)
		cmds << requestCode(state.checkCode)
	}
	if(cmds.size() > 1) {
		cmds = delayBetween(cmds, 4200)
	}
	cmds
}

/**
 * API endpoint for setting the user code length on a lock. This is specific to Schlage locks.
 *
 * @param length: The user code length
 *
 * @returns The command fired for writing the code length attribute
 */
def setCodeLength(length) {
	if (isSchlageLock()) {
		length = length.toInteger()
		if (length >= schlageParamMap.CodeLength.Min && length <= schlageParamMap.CodeLength.Max) {
			log.trace "[DTH] Executing 'setCodeLength()' by ${device.displayName}"
			def val = []
			val << length
			return secure(zwave.configurationV1.configurationSet(parameterNumber: schlageParamMap.CodeLength.Param, size: schlageParamMap.CodeLength.Size, configurationValue: val))
		}
	}
	return null
}

/**
 * API endpoint for getting the user code length on a lock.
 *
 * @returns The command fired for getting the code length attribute or if it isn't supported sets the value of attribute 'codeLength' to 0 and returns null
 */
def getCodeLength() {
    log.debug "Getting configured user pin code length"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = schlageParamMap.CodeLength.Param
        switch (state.MSR) { // check if we have a supported device
            // First do specific cases before moving to generic cases with regex matching
            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx
                log.info "Found Schlage FE5xx/BE3xx, fixed pin length 4 digits"
                sendEvent(name: "codeLength", value: 4, descriptionText: "Pin code length") // Fixed length 4 digits for these locks
                return [] // we're done here no command to send, it's fixed length for these locks
                break

            default:
                log.trace "Querying Schlage pin length"
                break
        }
    } else if (isYaleLock()) {
        log.info "Found Yale, 4-8 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 8, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isKwiksetLock()) { // Kwikset lock
        log.info "Found Kwikset, 4-8 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 8, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isSamsungLock()) { // Samsung lock
        log.info "Found Samsung, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isIDLock()) { // IDLock lock
        log.info "Found IDLock, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isDanaLockV2()) { // Danalock V2 lock
        log.info "Found DanalockV2, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isKeyWeLock()) {
        log.info "Found KeyWe, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isPoppKeypad()) { // Popp keypad
        log.info "Found Popp keypad, 4-10 digit pin lengths"
        sendEvent(name: "maxPINLength", value: 10, descriptionText: "Max pin code length")
        sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
        return [] // we're done here no command to send, it's defined range for these locks
    } else if (isLocstarLock()) { // Locstar
        switch (state.MSR) { // check if we have a supported device
            // First do specific cases before moving to generic cases with regex matching
            // TODO: Locstar support 4 or 6 digit code lengths however it does not provide a way to detect the code length as these are custom pre programmed lengths for each user
            case ~/015E-8015-.*/: // Locstar 8015
                //log.info "Found Locstar 8015 series, fixed pin length 6 digits"
                //sendEvent(name: "codeLength", value: 6, descriptionText: "Pin code length") // Fixed length 6 digits for these locks (master is 8 digits, users are 6)
                log.info "Found Locstar 8015 series, 4-6 digit pin length"
                sendEvent(name: "maxPINLength", value: 6, descriptionText: "Max pin code length")
                sendEvent(name: "minPINLength", value: 4, descriptionText: "Min pin code length")
                return [] // we're done here no command to send, it's fixed length for these locks
                break

            default:
                def msg = "Unknown Locstar model, cannot determine pin length. Contact developer, quote MSR $state.MSR"
                sendEvent(descriptionText: msg)
                log.warn msg
                return []
        }
    } else {
        log.warn "Unsupported device with MSR $state.MSR, cannot query pin length"
        sendEvent(name: "codeLength", value: 0) // Not supported
        return []
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

/**
 * API endpoint for setting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @param code: The code PIN
 *
 * @param codeName: The name of the code
 *
 * @returns cmds: The commands fired for creation and checking of a lock code
 */
def setCode(codeID, code, codeName = null) {
	if (!code) {
		log.trace "[DTH] Executing 'nameSlot()' by ${this.device.displayName}"
		nameSlot(codeID, codeName)
		return
	}
	
	log.trace "[DTH] Executing 'setCode()' by ${this.device.displayName}"
	def strcode = code
	if (code instanceof String) {
		code = code.toList().findResults { if(it > ' ' && it != ',' && it != '-') it.toCharacter() as Short }
	} else {
		strcode = code.collect{ it as Character }.join()
	}

	def strname = (codeName ?: "Code $codeID")
	state["setname$codeID"] = strname
	
    if (isIDLock() && !isIDLock101()) { // IDLock 150, starting 60 are keypad PIN users (user 1 is master and user 2 is service (remotely programmable) but we ignore for IDLock150)
        codeID = codeID + 59 // First keypad user is slot  for ST
    }
    def cmds = validateAttributes()
	cmds << secure(zwave.userCodeV1.userCodeSet(userIdentifier:codeID, userIdStatus:1, user:code))
    cmds << secure(zwave.userCodeV1.userCodeGet(userIdentifier:codeID)) // Some locks (e.g. IDLock) don't report the code update
	if(cmds.size() > 1) {
		cmds = delayBetween(cmds, 4200)
	}
	cmds
}

/**
 * Validates attributes and if attributes are not populated, adds the command maps to list of commands
 * @return List of commands or empty list
 */
def validateAttributes() {
	def cmds = []
	if(!device.currentValue("maxCodes")) {
		cmds << secure(zwave.userCodeV1.usersNumberGet())
	}
	if(!device.currentValue("codeLength")) {
		cmds << getCodeLength()
	}
	log.trace "validateAttributes returning commands list: " + cmds
	cmds
}

/**
 * API endpoint for setting/deleting multiple user codes on a lock
 *
 * @param codeSettings: The map with code slot numbers and code pins (in case of update)
 *
 * @returns The commands fired for creation and deletion of lock codes
 */
def updateCodes(codeSettings) {
	log.trace "[DTH] Executing updateCodes() for device ${device.displayName}"
	if(codeSettings instanceof String) codeSettings = util.parseJson(codeSettings)
	def set_cmds = []
	codeSettings.each { name, updated ->
		if (name.startsWith("code")) {
			def n = name[4..-1].toInteger()
			if (updated) { // Don't check code size here, leave it to the SmartApp as different locks have different limitations
				log.debug "Setting code number $n"
                if (isIDLock() && !isIDLock101()) { // IDLock 150, starting 60 are keypad PIN users (user 1 is master and user 2 is service (remotely programmable) but we ignore for IDLock150)
                    n = n + 59 // First keypad user is slot  for ST
                }
				set_cmds << secure(zwave.userCodeV1.userCodeSet(userIdentifier:n, userIdStatus:1, user:updated))
                set_cmds << secure(zwave.userCodeV1.userCodeGet(userIdentifier:n)) // Some locks don't report the code update
			} else if (updated == null || updated == "" || updated == "0") {
				log.debug "Deleting code number $n"
				set_cmds << deleteCode(n)
			}
		} else log.warn("unexpected entry $name: $updated")
	}
	if (set_cmds) {
		return response(delayBetween(set_cmds, 2200))
	}
	return null
}

/**
 * Renames an existing lock slot
 *
 * @param codeSlot: The code slot number
 *
 * @param codeName The new name of the code
 */
void nameSlot(codeSlot, codeName) {
	codeSlot = codeSlot.toString()
	if (!isCodeSet(codeSlot)) {
		return
	}
	def deviceName = device.displayName
	log.trace "[DTH] - Executing nameSlot() for device $deviceName"
	def lockCodes = loadLockCodes()
	def oldCodeName = getCodeName(lockCodes, codeSlot)
	def newCodeName = codeName ?: "Code $codeSlot"
	lockCodes[codeSlot] = newCodeName
	sendEvent(lockCodesEvent(lockCodes))
	sendEvent(name: "codeChanged", value: "$codeSlot renamed", data: [ lockName: deviceName, notify: false, notificationText: "Renamed \"$oldCodeName\" to \"$newCodeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Renamed \"$oldCodeName\" to \"$newCodeName\"", displayed: true, isStateChange: true)
}

/**
 * API endpoint for deleting a user code on a lock
 *
 * @param codeID: The code slot number
 *
 * @returns cmds: The command fired for deletion of a lock code
 */
def deleteCode(codeID) {
	log.trace "[DTH] Executing 'deleteCode()' by ${this.device.displayName}"
	// Calling user code get when deleting a code because some Kwikset locks do not generate
	// AlarmReport when a code is deleted manually on the lock
    if (isIDLock() && !isIDLock101()) { // IDLock 150, starting 60 are keypad PIN users (user 1 is master and user 2 is service (remotely programmable) but we ignore for IDLock150), also it needs user set to 0000 to delete the user
        codeID = codeID + 59 // First keypad user is slot  for ST
        secureSequence([
            zwave.userCodeV1.userCodeSet(userIdentifier:codeID, userIdStatus:0, user:"0000"), // IDLock 150 needs an explicit user 0000 to delete the code
            zwave.userCodeV1.userCodeGet(userIdentifier:codeID)
        ], 4200)
    } else {
        secureSequence([
            zwave.userCodeV1.userCodeSet(userIdentifier:codeID, userIdStatus:0),
            zwave.userCodeV1.userCodeGet(userIdentifier:codeID)
        ], 4200)
    }
}

/**
 * Encapsulates a command
 *
 * @param cmd: The command to be encapsulated
 *
 * @returns ret: The encapsulated command
 */
private secure(physicalgraph.zwave.Command cmd) {
	zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
}

/**
 * Encapsulates list of command and adds a delay
 *
 * @param commands: The list of command to be encapsulated
 *
 * @param delay: The delay between commands
 *
 * @returns The encapsulated commands
 */
private secureSequence(commands, delay=4200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

/**
 * Checks if the time elapsed from the provided timestamp is greater than the number of senconds provided
 *
 * @param timestamp: The timestamp
 *
 * @param seconds: The number of seconds
 *
 * @returns true if elapsed time is greater than number of seconds provided, else false
 */
private Boolean secondsPast(timestamp, seconds) {
	if (!(timestamp instanceof Number)) {
		if (timestamp instanceof Date) {
			timestamp = timestamp.time
		} else if ((timestamp instanceof String) && timestamp.isNumber()) {
			timestamp = timestamp.toLong()
		} else {
			return true
		}
	}
	return (now() - timestamp) > (seconds * 1000)
}

/**
 * Reads the code name from the 'lockCodes' map
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeName(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	lockCodes[codeID.toString()] ?: "Code $codeID"
}

/**
 * Reads the code name from the device state
 *
 * @param lockCodes: map with lock code names
 *
 * @param codeID: The code slot number
 *
 * @returns The code name
 */
private String getCodeNameFromState(lockCodes, codeID) {
	if (isMasterCode(codeID)) {
		return "Master Code"
	}
	def nameFromLockCodes = lockCodes[codeID.toString()]
	def nameFromState = state["setname$codeID"]
	if(nameFromLockCodes) {
		if(nameFromState) {
			//Updated from smart app
			return nameFromState
		} else {
			//Updated from lock
			return nameFromLockCodes
		}
	} else if(nameFromState) {
		//Set from smart app
		return nameFromState
	}
	//Set from lock
	return "Code $codeID"
}

/**
 * Check if a user code is present in the 'lockCodes' map
 *
 * @param codeID: The code slot number
 *
 * @returns true if code is present, else false
 */
private Boolean isCodeSet(codeID) {
	// BUG: Needed to add loadLockCodes to resolve null pointer when using schlage?
	def lockCodes = loadLockCodes()
	lockCodes[codeID.toString()] ? true : false
}

/**
 * Reads the 'lockCodes' attribute and parses the same
 *
 * @returns Map: The lockCodes map
 */
private Map loadLockCodes() {
	parseJson(device.currentValue("lockCodes") ?: "{}") ?: [:]
}

/**
 * Populates the 'lockCodes' attribute by calling create event
 *
 * @param lockCodes The user codes in a lock
 */
private Map lockCodesEvent(lockCodes) {
	createEvent(name: "lockCodes", value: util.toJson(lockCodes), displayed: false,
	descriptionText: "'lockCodes' attribute updated")
}

/**
 * Utility function to figure out if code id pertains to master code or not
 *
 * @param codeID - The slot number in which code is set
 * @return - true if slot is for master code, false otherwise
 */
private boolean isMasterCode(codeID) {
	if(codeID instanceof String) {
		codeID = codeID.toInteger()
	}
	(codeID == 0) ? true : false
}

/**
 * Creates the event map for user code creation
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @param codeName: The name of the user code
 *
 * @return The list of events to be sent out
 */
private def codeSetEvent(lockCodes, codeID, codeName) {
	clearStateForSlot(codeID)
	// codeID seems to be an int primitive type
	lockCodes[codeID.toString()] = (codeName ?: "Code $codeID")
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID is set"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for user code deletion
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID: The code slot number
 *
 * @return The list of events to be sent out
 */
private def codeDeletedEvent(lockCodes, codeID) {
	lockCodes.remove("$codeID".toString())
	// not sure if the trigger has done this or not
	clearStateForSlot(codeID)
	def result = []
	result << lockCodesEvent(lockCodes)
	def codeReportMap = [ name: "codeReport", value: codeID, data: [ code: "" ], isStateChange: true, displayed: false ]
	codeReportMap.descriptionText = "${device.displayName} code $codeID was deleted"
	result << createEvent(codeReportMap)
	result
}

/**
 * Creates the event map for all user code deletion
 *
 * @return The List of events to be sent out
 */
private def allCodesDeletedEvent() {
	def result = []
	def lockCodes = loadLockCodes()
	def deviceName = device.displayName
	lockCodes.each { id, code ->
		result << createEvent(name: "codeReport", value: id, data: [ code: "" ], descriptionText: "code $id was deleted",
					displayed: false, isStateChange: true)
		
		def codeName = code
		result << createEvent(name: "codeChanged", value: "$id deleted", data: [ codeName: codeName, lockName: deviceName,
			notify: true, notificationText: "Deleted \"$codeName\" in $deviceName at ${location.name}" ],
		descriptionText: "Deleted \"$codeName\"",
		displayed: true, isStateChange: true)
		clearStateForSlot(id)
	}
	result
}

/**
 * Checks if a change type is set or update
 *
 * @param lockCodes: The user codes in a lock
 *
 * @param codeID The code slot number
 *
 * @return "set" or "update" basis the presence of the code id in the lockCodes map
 */
private def getChangeType(lockCodes, codeID) {
	def changeType = "set"
	if (lockCodes[codeID.toString()]) {
		changeType = "changed"
	}
	changeType
}

/**
 * Method to obtain status for descriptuion based on change type
 * @param changeType: Either "set" or "changed"
 * @return "Added" for "set", "Updated" for "changed", "" otherwise
 */
private def getStatusForDescription(changeType) {
	if("set" == changeType) {
		return "Added"
	} else if("changed" == changeType) {
		return "Updated"
	}
	//Don't return null as it cause trouble
	return ""
}

/**
 * Clears the code name and pin from the state basis the code slot number
 *
 * @param codeID: The code slot number
 */
def clearStateForSlot(codeID) {
	state.remove("setname$codeID")
	state["setname$codeID"] = null
}

// CUSTOM STUFF
/**
 * Responsible for parsing ConfigurationReport command
 *
 * @param cmd: The ConfigurationReport command to be parsed
 *
 * @return The event(s) to be sent out
 *
 */
def zwaveEvent(physicalgraph.zwave.commands.configurationv2.ConfigurationReport cmd) { // Even though you're using V1 to read, ST seems to report it using V2 format, so process as V2
    log.trace "ConfigurationReport $cmd"
    def map = []

    if (isSchlageLock()) { // Schlage lock
        map << schlageConfigurationReport(cmd)
    } else if (isYaleLock()) { // Yale lock
        map << yaleConfigurationReport(cmd)
    } else if (isKwiksetLock()) { // Kwikset lock
        map << kwiksetConfigurationReport(cmd)
    } else if (isIDLock()) { // IDLock
        map << idLockConfigurationReport(cmd)
    } else if (isDanaLockV2()) { // Danalock V2
        map << danaLockConfigurationReportV2(cmd)
    } else if (isDanaLockV3()) { // Danalock V3
        map << danaLockConfigurationReportV3(cmd)
    } else if (isSamsungLock()) {
        map << samsungConfigurationReport(cmd)
    } else if (isPoppKeypad()) {
        map << poppConfigurationReport(cmd)
    } else if (isKeyWeLock()) {
        map << keyWeConfigurationReport(cmd)
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
    }

    runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register the new map

    //log.info map
    return map.flatten()
}

// Parse KeyWe lock parameters
private keyWeConfigurationReport(cmd) {
    log.trace "Processing KeyWe Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse Popp keypad parameters
private poppConfigurationReport(cmd) {
    log.trace "Processing Popp Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case poppParamMap.LockSecureTimeout.Param:
            map = [descriptionText: "Associated Door Lock Close Timeout: ${getPoppParamMap(cmd.configurationValue).LockSecureTimeout.Value} seconds"]
            break

        case poppParamMap.RingOffTimeout.Param:
            map = [descriptionText: "Associated Ring Button Off Timeout: ${getPoppParamMap(cmd.configurationValue).RingOffTimeout.Value} seconds"]
            break

        case poppParamMap.ReportUserCodes.Param:
            map = [descriptionText: "Report User Codes instead of Scene ID: ${cmd.scaledConfigurationValue ? "true" : "false"}"]
            break

        case poppParamMap.Buzzer.Param:
            map = [name: "beeper"]
            switch (cmd.scaledConfigurationValue) {
                case poppParamMap.Buzzer.Enabled:
                    map.value = "enabled"
                    break

                case poppParamMap.Buzzer.Disabled:
                    map.value = "disabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Buzzer ${map.value}"
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse Samsung lock parameters
private samsungConfigurationReport(cmd) {
    log.trace "Processing Samsung Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case samsungParamMap.PrivacyMode.Param: // Privacy mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock"]
            switch (cmd.scaledConfigurationValue) {
                case samsungParamMap.PrivacyMode.Disabled:
                    map.value = "enabled"
                    break

                case samsungParamMap.PrivacyMode.Enabled:
                    map.value = "disabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Keypad ${map.value}"
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse DanaLock V3 parameters
private danaLockConfigurationReportV3(cmd) {
    log.trace "Processing Danalock Configuration Report V3"
    def map = null

    switch (cmd.parameterNumber) {
        case danalockV3ParamMap.TurnAndGo.Param:
            map = [descriptionText: "Twist Assist/Turn And Go: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.BrakeAndGo.Param:
            map = [descriptionText: "Hold and Release/Brake And Go: ${getDanalockV3ParamMap(cmd.configurationValue).BrakeAndGo.Value} seconds"]
            break

        case danalockV3ParamMap.Async.Param:
            map = [descriptionText: "Async/Blocked 2 Blocked: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.BleTempAllowTimer.Param:
            map = [descriptionText: "Bluetooth Temporary Allow Timer: ${getDanalockV3ParamMap(cmd.configurationValue).BleTempAllowTimer.Value} seconds"]
            break

        case danalockV3ParamMap.BleAlwaysAllowed.Param:
            map = [descriptionText: "Bluetooth Always Allowed: ${cmd.configurationValue[0]}"]
            break

        case danalockV3ParamMap.AutoLock.Param:
            map = [name: "autolock"]
            switch(getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value) {
                case danalockV3ParamMap.AutoLock.Min:
                    map.value = "disabled"
                    map.descriptionText = "Auto lock ${map.value}"
                    break

                default:
                    map.value = "enabled"
                    map.descriptionText = "Auto Lock ${getDanalockV3ParamMap(cmd.configurationValue).AutoLock.Value} seconds"
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Process Danalock V2 parameters
private danaLockConfigurationReportV2(cmd) {
    log.trace "Processing Danalock Configuration Report V2"
    def map = null

    switch (cmd.parameterNumber) {
        case 1:
            map = [descriptionText: "Direction: ${cmd.configurationValue[0]}"]
            break

        case 2:
            map = [descriptionText: "Speed: ${cmd.configurationValue[0]}"]
            break

        case 3:
            map = [descriptionText: "Mode: ${cmd.configurationValue[0]}"]
            break

        case 4:
            map = [descriptionText: "Turn degrees: ${cmd.configurationValue[0]}"]
            break

        case 5:
            // Auto Lock
            map = [name: "autolock"]
            if (cmd.configurationValue[0] > 0) { // Auto lock
                map.value = "enabled"
                map.descriptionText = "Auto Lock ${cmd.configurationValue[0]} seconds"
            } else {
                map.value = "disabled"
                map.descriptionText = "Auto lock ${map.value}"
            }
            break

        case 6:
        	map = [name: "beeper"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 1:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Audio ${map.value}"
            break

        case 7:
            map = [descriptionText: "Battery type: ${cmd.configurationValue[0]}"]
            break

        case 8:
            map = [descriptionText: "Battery alarm level: ${cmd.configurationValue[0]}"]
            break

        case 9:
            map = [descriptionText: "Turn&Go: ${cmd.configurationValue[0]}"]
            break

        case 10:
            map = [descriptionText: "Brake&GoBack: ${cmd.configurationValue[0]} seconds"]
            break

        case 11:
            map = [descriptionText: "Async: ${cmd.configurationValue[0]}"]
            break

        case 12:
            map = [descriptionText: "Door Lock Operation Report type: ${cmd.configurationValue[0]}"]
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
        	break
    }

    return createEvent(map)
}

// Parse the IDLock parameters
private idLockConfigurationReport(cmd) {
    log.trace "Processing IDLock Configuration Report"
    def map = null
    def results = []
    def cmds = []

    switch (cmd.parameterNumber) {
        // Configuration parameter 1 is one byte code
        // Bit 0 Auto Lock Status (1: enable)
        // Bit 1 Away Mode Status (1: enable)
        case idLockParamMap.DoorLockMode.Param:
            switch (getIdLockParamMap(cmd.configurationValue).DoorLockMode.Value) {
                case 255:  // Can't read back only set or not yet initialized
                    map = []
                    map.descriptionText = "AutoLock and Keypad/Away mode not initialized, initializing now"
                    map.displayed = false
                    results << createEvent(map)
                    // Lets try to force an initialization as they kick starts reporting
                    def value = [idLockParamMap.DoorLockMode.Default]
                    log.info "Forcing initialization of IDLock Enabling AutoLock/Keypad Disabling Away Mode -> ${value}"
                    cmds << zwave.configurationV1.configurationSet(parameterNumber: idLockParamMap.DoorLockMode.Param, configurationValue: value)
                    cmds << zwave.configurationV1.configurationGet(parameterNumber: idLockParamMap.DoorLockMode.Param)
                    break

                default:
                    // Away Mode
                    map = [name: "codeunlock"]
                    if (cmd.configurationValue[0] & 0x2) { // Away Mode enabled = Keypad disable
                        map.value = "disabled"
                        map.descriptionText = "Activated Away mode, Keypad ${map.value}"
                    } else {
                        map.value = "enabled"
                        map.descriptionText = "Deactivated Away mode, Keypad ${map.value}"
                    }
                    results << createEvent(map)

                    // Auto Lock
                    map = [name: "autolock"]
                    if (cmd.configurationValue[0] & 0x1) { // Auto lock
                        map.value = "enabled"
                    } else {
                        map.value = "disabled"
                    }
                    map.descriptionText = "Auto lock ${map.value}"
                    results << createEvent(map)
                    break
            }
            break
            
        case idLockParamMap.DoorHingeLeft.Param:
            map = [descriptionText: "Door hinge mode: ${cmd.scaledConfigurationValue ? "Left Handle" : "Right Handle"}"]
            results << createEvent(map)
            break

        case idLockParamMap.RelockMode.Param:
            map = [descriptionText: "Relock mode: ${cmd.scaledConfigurationValue ? "Enabled" : "Disabled"}"]
            results << createEvent(map)
            break

        case idLockParamMap.AudioVolumeLevel.Param:
        	def level = ""
        	map = [name: "beeper"]
            switch (getIdLockParamMap(cmd.configurationValue).AudioVolumeLevel.Value) {
                case 0:
                    map.value = "disabled"
                    break
                    
                case 255:  // Can't read back only set or not yet initialized
                    map.value = "unknown"
                    map.displayed = false
                    level = ", volume level not initialized"
                    // Lets try to force an initialization as they kick starts reporting
                    def value = ((idlockVolume as Integer) && ((idlockVolume as Integer) >= idLockParamMap.AudioVolumeLevel.Min && (idlockVolume as Integer) <= idLockParamMap.AudioVolumeLevel.Max)) ? getIdLockParamMap(idlockVolume as Integer).AudioVolumeLevel.ParamValue : [idLockParamMap.AudioVolumeLevel.Default]
                    log.info "Forcing initialization of IDLock setting volume level -> ${value}"
                    cmds << zwave.configurationV1.configurationSet(parameterNumber: idLockParamMap.AudioVolumeLevel.Param, configurationValue: value)
                    cmds << zwave.configurationV1.configurationGet(parameterNumber: idLockParamMap.AudioVolumeLevel.Param)
                    break

                default:
                    if ((getIdLockParamMap(cmd.configurationValue).AudioVolumeLevel.Value >= idLockParamMap.AudioVolumeLevel.Min) && (getIdLockParamMap(cmd.configurationValue).AudioVolumeLevel.Value <= idLockParamMap.AudioVolumeLevel.Max)) {
                        map.value = "enabled"
                        level = ", volume ${getIdlockVolumeOptions()[getIdLockParamMap(cmd.configurationValue).AudioVolumeLevel.Value as String]}"
                    } else {
                        map.value = "unknown"
                        map.displayed = false
                        level = ", volume level ${getIdLockParamMap(cmd.configurationValue).AudioVolumeLevel.Value}"
                    }
                    break
            }
            map.descriptionText = "Audio ${map.value}" + level
            results << createEvent(map)
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            results << createEvent(map)
	        break
    }

    if (cmds) { // If we have any follow up commands lets send them out
        def hubAction = response(delayBetween(cmds.collect { it.format() }, 4200)) // IDLock doesn't support secure channel for configuration
        sendHubCommand(hubAction.toHubAction())
    }
    
    return results
}

// Parse the Kwikset parameters
private kwiksetConfigurationReport(cmd) {
    log.trace "Processing Kwikset Configuration Report"
    def map = null
    def results = []

    switch (cmd.parameterNumber) {
        // Configuration parameter 31 is one byte read only bit mask field that returns the state of the user accessible Dipswitches on the door lock
        // Bit 0 Lock LED Status (1: enable)
        // Bit 1 Auto lock (1: enable)
        // Bit 2 Auto Buzzer (1: enable)
        // Bit 3 Secure Screen (1: enable) *Only for MB 916
        case 31:
            // Beeper
            map = [name: "beeper"]
            if (cmd.configurationValue[0] & 0x4) { // Beeper
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
            map.descriptionText = "Audio ${map.value}"
            results << createEvent(map)

            // Auto Lock
            map = [name: "autolock"]
            if (cmd.configurationValue[0] & 0x2) { // Auto lock
                map.value = "enabled"
            } else {
                map.value = "disabled"
            }
            map.descriptionText = "Auto lock ${map.value}"
            results << createEvent(map)
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            results << createEvent(map)
	        break
    }

    return results
}

// Parse the Yale parameters
private yaleConfigurationReport(cmd) {
    log.trace "Processing Yale Configuration Report"
    def map = null

    switch (cmd.parameterNumber) {
        case 1: // Beeper, Assa Abloy and Yale have it in reverse to each other
        map = [name: "beeper"]
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                switch (cmd.configurationValue[0]) {
                    case 1:
                    case 2:
                        map.value = "enabled"
                        break

                    case 3:
                        map.value = "disabled"
                        break

                    default:
                        map.value = "unknown"
                    	map.displayed = false
                    	break
                }
                break
                
            default: // All the rest of Yale
                switch (cmd.configurationValue[0]) {
                    case 1:
	                    map.value = "disabled"
    	                break

                    case 3:
                    case 2:
                        map.value = "enabled"
                        break

                    default:
                        map.value = "unknown"
        	            map.displayed = false
           				break
                }
                break
        }
        map.descriptionText = "Audio ${map.value}"
        break

        case 2: // Auto lock
            map = [name: "autolock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Auto lock ${map.value}"
            break

        case 3: // Auto relock time
            map = [descriptionText: "Auto relock time ${cmd.configurationValue[0]} seconds"]
            break

        case 4: // Wrong code entry limit
            map = [descriptionText: "Wrong code entry tamper alert limit ${cmd.configurationValue[0]}"]
            break

        case 5: // Language
            switch (cmd.configurationValue[0]) {
                case 0:
                    map = [descriptionText: "Language English"]
                    break

                case 1:
                    map = [descriptionText: "Language Spanish"]
                    break

                case 2:
                    map = [descriptionText: "Language French"]
                    break

                default:
                    map = [descriptionText: "Language Unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 7: // Shutdown time after wrong entries
            map = [descriptionText: "Shutdown time ${cmd.configurationValue[0]} seconds"]
            break

        case 8: // Vacation mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "enabled"
                    break

                case 1:
                case 2:
                    map.value = "disabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Keypad ${map.value}"
            break

        case 11: // One touch locking
            map = [name: "onetouchlock"]
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "One touch locking ${map.value}"
            break

        case 12: // Privacy button
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Privacy button off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Privacy button on"]
                    break

                default:
                    map = [descriptionText: "Privacy button unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 13: // Lock status LED
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Lock status LED off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Lock status LED on"]
                    break

                default:
                    map = [descriptionText: "Lock status LED unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        case 18: // Door propped timer
            map = [descriptionText: "Door propped ${cmd.configurationValue[0]*10} seconds"]
            break

        case 19: // DPS Alarm
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map = [descriptionText: "Door position sensor state off"]
                    break

                case 0xFF:
                    map = [descriptionText: "Door position sensor state on"]
                    break

                default:
                    map = [descriptionText: "Door position sensor state unknown: ${cmd.configurationValue[0]}"]
                    break
            }
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    return createEvent(map)
}

// Parse the Schlage parameters
private schlageConfigurationReport(cmd) {
    log.trace "Processing Schlage Configuration Report"
    def map = null
    def result = []

    switch (cmd.parameterNumber) {
        case 0x03: // Beeper
            map = [name: "beeper"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0x1:
                    switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                            map.value = "enabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                case 0xff:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Audio ${map.value}"
            break

        case 0x04: // Vacation mode enabled -> Keypad disabled and vice versa
            map = [name: "codeunlock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "enabled"
                    break

                case 0x1:
                    switch (state.MSR) {
                        case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                            map.value = "disabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                case 0xff:
                    switch (state.MSR) {
                        case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
                        case ~/003B-6349-.*/: // Schlage BE468 Generic
                            map.value = "disabled"
                            break

                        default:
                            map.value = "unknown"
                            map.displayed = false
                            break
                    }
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Keypad ${map.value}"
            break

        case 0x05: // Lock and Leave
            map = [name: "onetouchlock"]
            switch (cmd.configurationValue[0]) {
                case 0x0:
                    map.value = "disabled"
                    break

                case 0xFF:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Lock & leave ${map.value}"
            break

        case 0x07: // Lock specific alarm mode
            map = [name: "alarm"]
            switch (cmd.configurationValue[0]) {
                case 0:
                	result << createEvent(name: "sensitive", value: "", descriptionText: "No Alarm Sensitivity for off") // When alarm is off there is no sensitive level
                    map.value = "off"
                    break

                case 0x1:
                    map.value = "alert"
                    break

                case 0x2:
                    map.value = "tamper"
                    break

                case 0x3:
                    map.value = "forced"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Alarm mode ${map.value}"
            break

        case 0x08:
        case 0x09:
        case 0x0A: // Lock specific alarm sensitivity level
            map = [name: "sensitive"]
            switch (cmd.configurationValue[0]) {
                case 0x1:
                    map.value = "highest"
                    break

                case 0x2:
                    map.value = "high"
                    break

                case 0x3:
                    map.value = "medium"
                    break

                case 0x4:
                    map.value = "low"
                    break

                case 0x5:
                    map.value = "lowest"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Alarm sensitivity level ${map.value}"
            break

        case 0x0F: // Auto lock
            map = [name: "autolock"]
            switch (cmd.configurationValue[0]) {
                case 0:
                    map.value = "disabled"
                    break

                case 0xff:
                    map.value = "enabled"
                    break

                default:
                    map.value = "unknown"
                    map.displayed = false
                    break
            }
            map.descriptionText = "Auto lock ${map.value}"
            break

        case 0x10: // Pin code length
            def length = cmd.scaledConfigurationValue
            def deviceName = device.displayName
            log.trace "[DTH] Executing 'ConfigurationReport' for device $deviceName with code length := $length"
            def codeLength = device.currentValue("codeLength")
            if (codeLength && codeLength != length) {
                log.trace "[DTH] Executing 'ConfigurationReport' for device $deviceName - all codes deleted"
                result = allCodesDeletedEvent()
                result << createEvent(name: "codeChanged", value: "all deleted", descriptionText: "Deleted all user codes", isStateChange: true, data: [lockName: deviceName, notify: true, notificationText: "Deleted all user codes in $deviceName at ${location.name}"])
                result << createEvent(name: "lockCodes", value: util.toJson([:]), displayed: false, descriptionText: "'lockCodes' attribute updated")
            }
            result << createEvent(name:"codeLength", value: length, descriptionText: "Code length is $length", displayed: false)
            break

        default:
            map = [ displayed: false, descriptionText: "$device.displayName: Parameter $cmd.parameterNumber configuration $cmd.configurationValue" ]
            break
    }

    if (map) {
        result << createEvent(map)
    }
    
    return result
}

private getKeypadState() {
    log.debug "Getting keypad state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 4
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 8
    } else if (isIDLock()) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
    } else if (isSamsungLock()) { // Samsung
        log.trace "Found Samsung"
        parameter = samsungParamMap.PrivacyMode.Param
    } else {
        log.warn "Unknown device with MSR $state.MSR, keypad state not available"
        sendEvent(name: "codeunlock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableKeypad() {
    log.debug "Enabling keypad"

    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad enable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 4
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 8
        value = [0]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
        if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("autolock") == "disabled") {
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not enabling Keypad"
            sendEvent(descriptionText: "Cannot determine Keypad state, not enabling Keypad", isStateChange: true, displayed: true)
            return
        }
    } else if (isSamsungLock()) { // Samsung
        parameter = samsungParamMap.PrivacyMode.Param
        value = [samsungParamMap.PrivacyMode.Disabled]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableKeypad() {
    log.debug "Disabling keypad"

    if (!(device.currentState('codeunlock')?.value && (device.currentState('codeunlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Keypad disable feature not available"
        sendEvent(name: "contactDeveloper", value: "Feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = 4
        switch (state.MSR) { // model based
            // First do specific cases before moving to generic cases with regex matching
            case ~/003B-6341-.*/: // Schlage FE/BE469 Generic
            case ~/003B-6349-.*/: // Schlage BE468 Generic
                value = [255]
                break

            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
                value = [1]
                break

            default:
                value = [255] // Default most Schlage locks use this try it out
                log.warn "Unknown Schlage device with MSR $state.MSR, contact developer, Keypad disable feature may not work"
                sendEvent(name: "contactDeveloper", value: "Unsupported lock, keypad disable feature may not work. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
                break
        }
    } else if (isYaleLock()) { // Yale lock
        parameter = 8
        value = [1] // Vacation mode (don't use privacy mode for consistency)
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
        if (device.currentValue("autolock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("autolock") == "disabled") {
            value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine AutoLock state, not disabling Keypad"
            sendEvent(descriptionText: "Cannot determine AutoLock state, not disabling Keypad", isStateChange: true, displayed: true)
            return
        }
    } else if (isSamsungLock()) { // Samsung
        parameter = samsungParamMap.PrivacyMode.Param
        value = [samsungParamMap.PrivacyMode.Enabled]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private getAudioState() {
    log.debug "Getting audio/beeper state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 3
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 1
    } else if (isKwiksetLock()) { // kwikset lock
        log.trace "Found Kwikset Lock"
        parameter = 31
    } else if (isDanaLockV2()) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 6
    } else if (isPoppKeypad()) { // Popp keypad
        log.trace "Found Popp keypad"
        parameter = poppParamMap.Buzzer.Param
    } else if (isIDLock()) { // IDlock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.AudioVolumeLevel.Param
    } else {
        log.warn "Unknown device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "beeper", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableAudio() {
    log.debug "Enabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = 3
        switch (state.MSR) {
            case ~/003B-634B-.*/: // Schlage FE5xx/BE3xx Series Generic
            value = [1]
            break

            default:
                value = [255]
            break
        }
    } else if (isYaleLock()) { // Yale lock
        parameter = 1
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                value = [yaleAudioLevelLow ? 2 : 1]
                break
            
            default: // Yale
                value = [yaleAudioLevelLow ? 2 : 3]
                break
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely enabling Audio, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely enabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 6
        value = [1]
    } else if (isPoppKeypad()) { // Popp keypad
        parameter = poppParamMap.Buzzer.Param
        value = [poppParamMap.Buzzer.Enabled]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.AudioVolumeLevel.Param
        value = ((idlockVolume as Integer) && ((idlockVolume as Integer) >= idLockParamMap.AudioVolumeLevel.Min && (idlockVolume as Integer) <= idLockParamMap.AudioVolumeLevel.Max)) ? getIdLockParamMap(idlockVolume as Integer).AudioVolumeLevel.ParamValue : [idLockParamMap.AudioVolumeLevel.Default]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableAudio() {
    log.debug "Disabling audio/beeper" 

    if (!(device.currentState('beeper')?.value && (device.currentState('beeper')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Audio/Beeper feature not available"
        sendEvent(name: "contactDeveloper", value: "Audio/Beeper feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        parameter = 3
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 1
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                value = [3]
                break
            
            default: // Yale
                value = [1]
                break
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely disabling Audio, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely disabling Audio, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 6
        value = [0]
    } else if (isPoppKeypad()) { // Popp keypad
        parameter = poppParamMap.Buzzer.Param
        value = [poppParamMap.Buzzer.Disabled]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.AudioVolumeLevel.Param
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private getOneTouchLockState() {
    log.debug "Getting OneTouch Lock state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 5
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 11
    } else {
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not supported"
        sendEvent(name: "onetouchlock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableOneTouchLock() {
    log.debug "Enabling OneTouch Lock" 

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 5
        value = [255]
    } else if (isYaleLock()) { // Yale lock
        parameter = 11
        value = [255]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableOneTouchLock() {
    log.debug "Disabling OneTouch Lock"

    if (!(device.currentState('onetouchlock')?.value && (device.currentState('onetouchlock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, OneTouch Lock feature not available"
        sendEvent(name: "contactDeveloper", value: "OneTouch Lock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 5
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 11
        value = [0]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private getAutolockState() {
    log.debug "Getting AutoLock state"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 15
    } else if (isYaleLock()) { // Yale lock
        log.trace "Found Yale"
        parameter = 2
    } else if (isKwiksetLock()) { // kwikset lock
        log.trace "Found Kwikset"
        parameter = 31
    } else if (isIDLock()) { // IDLock
        log.trace "Found IDLock"
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
    } else if (isDanaLockV2()) { // Danalock V2
        log.trace "Found Danalock V2"
        parameter = 5
    } else if (isDanaLockV3()) { // Danalock V3
        log.trace "Found Danalock V3"
        parameter = danalockV3ParamMap.AutoLock.Param
    } else {
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not supported"
        sendEvent(name: "autolock", value: "", displayed: false) // Not supported
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}	

def enableAutolock() {
    log.debug "Enabling AutoLock" 

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 15
        value = [255]
    } else if (isYaleLock()) { // Yale lock
        parameter = 2
        value = [255]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x1] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not enabling AutoLock"
            sendEvent(descriptionText: "Cannot determine Away mode state, not enabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely enabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 5
        value = [danaRelockTime ? (danaRelockTime <= 60 ? danaRelockTime : 60) : 30] // Default is 30 if not specified in settings, maximum value is 60 for V2 locks
    } else if (isDanaLockV3()) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(danaRelockTime ?: 30).AutoLock.ParamValue // Default is 30 if not specified in settings
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

def disableAutolock() {
    log.debug "Disabling AutoLock"

    if (!(device.currentState('autolock')?.value && (device.currentState('autolock')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, AutoLock feature not available"
        sendEvent(name: "contactDeveloper", value: "AutoLock feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def parameter
    def security = true
    def value = []
    if (isSchlageLock()) { // Schlage lock
        parameter = 15
        value = [0]
    } else if (isYaleLock()) { // Yale lock
        parameter = 2
        value = [0]
    } else if (isIDLock()) { // IDLock
        security = false // ID Lock uses non secure channel for configuration class
        parameter = idLockParamMap.DoorLockMode.Param
        if (device.currentValue("codeunlock") == "enabled") { // Away mode enabled = keypad disabled
            value = [0x0 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else if (device.currentValue("codeunlock") == "disabled") {
            value = [0x2 | 0x0] // Bit 1 AutoLock, Bit 2 Away mode
        } else {
            log.error "IDLock device with MSR $state.MSR, cannot determine Away mode state, not disabling AutoLock"
            sendEvent(descriptionText: "Cannot determine Away mode state, not disabling AutoLock", isStateChange: true, displayed: true)
            return
        }
    } else if (isKwiksetLock()) { // Kwikset does not support setting remotely only reading
        log.warn "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock"
        sendEvent(descriptionText: "Kwikset lock does not support remotely disabling AutoLock, change settings on the lock", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    } else if (isDanaLockV2()) { // Danalock V2
        parameter = 5
        value = [0]
    } else if (isDanaLockV3()) { // Danalock V3
        parameter = danalockV3ParamMap.AutoLock.Param
        value = getDanalockV3ParamMap(0).AutoLock.ParamValue
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            zwave.configurationV1.configurationGet(parameterNumber: parameter)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
        ], 5000)
    }
}	

private modes() {
    ["off", "alert", "tamper", "forced"]
}

private getModeMap() {
    [
        "off": 0,
        "alert": 1,
        "tamper": 2,
        "forced": 3
    ]
}

private getAlarmLevel() {
    log.debug "Getting Alarm Level"

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not supported"
        sendEvent(name: "alarm", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setAlarm(String newMode) {
    log.debug "Set Alarm level to $newMode"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!modes().contains(newMode)) {
        log.error "Request to set unknown Alarm mode $newMode"
        return
    }

    log.info "SetAlarm setting Alarm mode to $newMode -> ${[modeMap[newMode]]}"

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        parameter = 7
        value = [modeMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            //secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)), // It returns the new value after setting, no need to fetch
            getSensitiveLevel(newMode)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter).format(), // It returns the new value after setting, no need to fetch
            getSensitiveLevel(newMode)
        ], 5000)
    }
}

def alarmToggle() {
    log.debug "Set Alarm Toggle"

    if (!(device.currentState('alarm')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def currentMode = device.currentState("alarm")?.value
    log.trace "AlarmToggle Current Alarm mode is $currentMode"
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.warn "Lock initialization not complete, deferring toggle alarm. Try again later after refreshing lock status."
        return
    }

    def modeOrder = modes()
    def next = { modeOrder[modeOrder.indexOf(it) + 1] ?: modeOrder[0] }
    def nextMode = next(currentMode)

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"

        log.info "AlarmToggle Setting Alarm mode to $nextMode -> ${modeMap[nextMode]}"

        parameter = 7
        value = [modeMap[nextMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        delayBetween([
            secure(zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value)),
            //secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)), // It returns the new value after setting, no need to fetch
            getSensitiveLevel(nextMode)
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter).format(), // It returns the new value after setting, no need to fetch
            getSensitiveLevel(nextMode)
        ], 5000)
    }
}

private sensitives() {
    ["lowest", "low", "medium", "high", "highest"]
}

private getSensitiveMap() {
    [
        "highest": 1,
        "high": 2,
        "medium": 3,
        "low": 4,
        "lowest" : 5
    ]
}

def getSensitiveLevel() {
    def currentMode = device.currentState("alarm")?.value
    getSensitiveLevel(currentMode)
}

def getSensitiveLevel(currentMode) {
    log.debug "Getting Sensitivity Level, current Alarm Mode $currentMode"

    if (!(currentMode && (currentMode != "unknown"))) { // Sometime when the initialization is not complete, we get a null here or if Alarm is unsupported we get a unknown, so avoid a crash and wait
        log.warn "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "GetSensitiveLevel Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }
        parameter = 7 + currentModeValue
    } else {
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not supported"
        sendEvent(name: "sensitive", value: "", displayed: false) // Not supported
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    security ? secure(zwave.configurationV1.configurationGet(parameterNumber: parameter)) : zwave.configurationV1.configurationGet(parameterNumber: parameter).format()
}

def setSensitivity(String newMode) {
    log.debug "Set Alarm Sensitivity to $newMode"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (!sensitives().contains(newMode)) {
        log.error "Request to set unknown Alarm sensitivity $newMode"
        return
    }

    def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }

        log.info "Set Alarm Sensitivity to $newMode -> ${[sensitiveMap[newMode]]}"

        parameter = 7 + currentModeValue
        value = [sensitiveMap[newMode]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter), // It reports the value automatically after setting, don't overload mesh
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter).format(), // It reports the value automatically after setting, don't overload mesh
        ], 5000)
    }
}

def sensitiveToggle() {
    log.debug "Set Alarm Sensitivity Toggle"

    if (!(device.currentState('sensitive')?.value && (device.currentState('alarm')?.value != "unknown"))) { // Check if we have succesfully managed to read the feature state, if not then it isn't supported
        log.warn "Unsupported device with MSR $state.MSR, Alarm Sensitivity feature not available"
        sendEvent(name: "contactDeveloper", value: "Alarm Sensitivity feature not supported, MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    def currentMode = device.currentState("alarm")?.value
    if (!currentMode) { // Sometime when the initialization is not complete, we get a null here, so avoid a crash and wait
        log.debug "Lock Alarm mode not configured or not supported, deferring getting Alarm sensitivity level."
        sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
        runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
        return
    }

    def parameter
    def value = []
    def security = true
    if (isSchlageLock()) { // Schlage lock
        log.trace "Found Schlage"
        int currentModeValue = modeMap[currentMode]
        log.trace "SensitiveToggle Current Alarm mode is $currentMode -> $currentModeValue"
        if (currentMode == "off") { // In off mode there is no sensitivity level
            log.info "There is no sensitive level when alarm is in off mode"
            sendEvent(name: "sensitive", value: "", displayed: false, isStateChange: true) // There is no sensitive level for off
            runIn(5, updateTiles) // Update the alarm status on the tiles after 5 seconds giving it time to register
            return
        }

        def currentSensitive = device.currentState("sensitive")?.value
        log.trace "SensitiveToggle Current Alarm sensitivity is $currentSensitive"
        def SensitiveOrder = sensitives()
        def next = { SensitiveOrder[SensitiveOrder.indexOf(it) + 1] ?: SensitiveOrder[0] }
        def nextSensitive = next(currentSensitive)

        log.info "Toggling Alarm Sensitivity to $nextSensitive -> ${sensitiveMap[nextSensitive]}"

        parameter = 7 + currentModeValue
        value = [sensitiveMap[nextSensitive]]
    } else {
        log.warn "Unknown device with MSR $state.MSR, report it to developer"
        sendEvent(name: "contactDeveloper", value: "Unknown lock. Contact developer, quote MSR $state.MSR", isStateChange: true, displayed: true) // Report to dev with MSR
        return
    }

    if (security) {
        secureSequence([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter), // It reports the value automatically after setting, don't overload mesh
        ], 5000)
    } else {
        delayBetween([
            zwave.configurationV1.configurationSet(parameterNumber: parameter, configurationValue: value).format(),
            //zwave.configurationV1.configurationGet(parameterNumber: parameter).format(), // It reports the value automatically after setting, don't overload mesh
        ], 5000)
    }
}

/**
 * Getting the battery state
 *
 * @returns The command fired for getting the battery state on a lock
 */
private getBatteryState() {
    // Some locks implement non secure reading of battery
    def security = true

    if (isIDLock101()) { // IDLock 101 reports battery on non secure channel
        security = false
    }

    security ? secure(zwave.batteryV1.batteryGet()) : zwave.batteryV1.batteryGet().format()
}

/**
 * Configuring the parameters on a lock
 *
 * @returns The command fired for sending the configuration settings to the lock or null if it's an unsupported lock
 */
private configureLock() {
    log.trace "$device.displayName: Configuring lock settings"
    def map = null
    
    if (isSchlageLock()) { // Schlage lock
        map = schlageConfigureLock()
    } else if (isYaleLock()) { // Yale lock
        map = yaleConfigureLock()
    } else if (isKwiksetLock()) { // Kwikset lock
        map = kwiksetConfigureLock()
    } else if (isIDLock()) { // IDLock
        map = idLockConfigureLock()
    } else if (isDanaLockV2()) { // Danalock V2
        map = danaLockConfigureLockV2()
    } else if (isDanaLockV3()) { // Danalock V3
        map = danaLockConfigureLockV3()
    } else if (isPoppKeypad()) { // Popp keypad
        map = poppConfigureKeypad()
    } else if (isKeyWeLock()) { // KeyWe lock
        map = keyWeConfigureLock()
    } else {
        log.warn "Unsupported device with MSR $state.MSR"
    }

    return map    
}

private keyWeConfigureLock() {
    log.trace "Configure KeyWe lock settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private poppConfigureKeypad() {
    log.trace "Configure Popp keypad settings"
    def cmds = []

    log.debug "Enabling user code reporting"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: poppParamMap.ReportUserCodes.Param, configurationValue: [poppParamMap.ReportUserCodes.Enabled])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: poppParamMap.ReportUserCodes.Param)

    cmds ? secureSequence(cmds, 5000) : null
}

private yaleConfigureLock() {
    log.trace "Configure Yale settings"
    def cmds = []

    if (device.currentValue('beeper') == "enabled") {
        log.info "Audio enabled, updating audio volume level to ${yaleAudioLevelLow ? "low" : "high"}"
        def value = []
        switch (state.MSR) {
            case ~/0129-80.*/: // Commercial
                value = [yaleAudioLevelLow ? 2 : 1]
                break
            
            default: // Yale
                value = [yaleAudioLevelLow ? 2 : 3]
                break
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: value)
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 1)
    }
    
    if (yaleWrongCodeLimit) {
        if (yaleWrongCodeLimit >=1 && yaleWrongCodeLimit <= 7) {
            log.info "Setting Wrong Code Tamper Alert threshold to $yaleWrongCodeLimit"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, configurationValue: [yaleWrongCodeLimit])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        } else {
            log.warn "Wrong Code Tamper Alert threshold INVALID (between 1 and 7) -> $yaleWrongCodeLimit"
        }
    }
    
    if (yaleWrongCodeLockout) {
        if (yaleWrongCodeLockout >=10 && yaleWrongCodeLockout <= 180) {
            log.info "Setting Wrong Code Keypad Shutdown Time to $yaleWrongCodeLockout"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 7, configurationValue: [yaleWrongCodeLockout])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 7)
        } else {
            log.warn "Wrong Code Keypad Shutdown Time INVALID (between 10 and 180) -> $yaleWrongCodeLockout"
        }
    }

    if (yaleRelockTime) {
        if (yaleRelockTime >=5 && yaleRelockTime <= 255) {
            log.info "Setting Auto Relock time to $yaleRelockTime seconds"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, configurationValue: [yaleRelockTime])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        } else {
            log.warn "Auto Relock time INVALID (between 5 and 255) -> $yaleRelockTime seconds"
        }
    }

    log.info "${yaleDPS ? "Enabling" : "Disabling"} DPS functionality"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: 19, configurationValue: [yaleDPS ? 255 : 0])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: 19)

    cmds ? secureSequence(cmds, 5000) : null
}

private kwiksetConfigureLock() {
    log.trace "Configure Kwikset settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private schlageConfigureLock() {
    log.trace "Configure Schlage settings"
    def cmds = []

    cmds ? secureSequence(cmds, 5000) : null
}

private idLockConfigureLock() {
    log.trace "Configure IDLock settings"
    def cmds = []
    
    if (idlockVolume as Integer) {
        if ((idlockVolume as Integer) < idLockParamMap.AudioVolumeLevel.Min || (idlockVolume as Integer) > idLockParamMap.AudioVolumeLevel.Max) {
            log.warn "Invalid volume level (between ${idLockParamMap.AudioVolumeLevel.Min} and ${idLockParamMap.AudioVolumeLevel.Max}) -> ${(idlockVolume as Integer)} using default volume level ${idLockParamMap.AudioVolumeLevel.Default}"
        }
    }

    // The lock won't report the audio state until it's been initialized atleast once
    if (!(device.currentState('beeper')?.value) || (device.currentState('beeper')?.value == "unknown")) {
        def value = ((idlockVolume as Integer) && ((idlockVolume as Integer) >= idLockParamMap.AudioVolumeLevel.Min && (idlockVolume as Integer) <= idLockParamMap.AudioVolumeLevel.Max)) ? getIdLockParamMap(idlockVolume as Integer).AudioVolumeLevel.ParamValue : [idLockParamMap.AudioVolumeLevel.Default]
        log.info "Setting IDLock volume level -> ${value}"
        cmds << zwave.configurationV1.configurationSet(parameterNumber: idLockParamMap.AudioVolumeLevel.Param, configurationValue: value)
        cmds << zwave.configurationV1.configurationGet(parameterNumber: idLockParamMap.AudioVolumeLevel.Param)
    }
    
    // Lock won't report autolock state until it's been initialized atleast once
    if (!(device.currentState('autolock')?.value) || (device.currentState('autolock')?.value == "unknown")) {
        def value = [idLockParamMap.DoorLockMode.Default]
        log.info "Forcing initialization of IDLock Enabling AutoLock/Keypad Disabling Away Mode -> ${value}"
        cmds << zwave.configurationV1.configurationSet(parameterNumber: idLockParamMap.DoorLockMode.Param, configurationValue: value)
        cmds << zwave.configurationV1.configurationGet(parameterNumber: idLockParamMap.DoorLockMode.Param)
    }
    
    log.info "Setting Unopened Door Relock Mode -> ${idlockRelock ? "Enabled" : "Disabled"}"
    cmds << zwave.configurationV1.configurationSet(parameterNumber: idLockParamMap.RelockMode.Param, configurationValue: [ idlockRelock ? idLockParamMap.RelockMode.Enabled : idLockParamMap.RelockMode.Disabled ])
    cmds << zwave.configurationV1.configurationGet(parameterNumber: idLockParamMap.RelockMode.Param)

    cmds ? delayBetween(cmds.collect { it.format() }, 5000) : null // IDLock uses non secure channel for configuration class
}

private danaLockConfigureLockV3() {
    log.trace "Configure Danalock V3 settings"
    def cmds = []

    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >= danalockV3ParamMap.BrakeAndGo.Min && danaBrakeGoBack <= danalockV3ParamMap.BrakeAndGo.Max) {
            if (danaBrakeGoBack == danalockV3ParamMap.BrakeAndGo.Min) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param, configurationValue: getDanalockV3ParamMap(danaBrakeGoBack).BrakeAndGo.ParamValue)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.BrakeAndGo.Param)
        } else {
            log.warn "Brake & Go Back time INVALID (between ${danalockV3ParamMap.BrakeAndGo.Min} and ${danalockV3ParamMap.BrakeAndGo.Max}) -> $danaBrakeGoBack seconds"
        }
    }

    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param, configurationValue: [danaTurnGo ? danalockV3ParamMap.TurnAndGo.Enabled : danalockV3ParamMap.TurnAndGo.Disabled])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: danalockV3ParamMap.TurnAndGo.Param)
    }

    cmds ? secureSequence(cmds, 5000) : null
}

private danaLockConfigureLockV2() {
    log.trace "Configure Danalock V2 settings"
    def cmds = []

    if (danaBrakeGoBack != null && danaBrakeGoBack != "") {
        if (danaBrakeGoBack >=0 && danaBrakeGoBack <= 15) {
            if (danaBrakeGoBack == 0) {
                log.info "Disabling Brake & Go back"
            } else {
                log.info "Setting Brake & Go Back time to $danaBrakeGoBack seconds"
            }

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 10, configurationValue: [danaBrakeGoBack])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 10)
        } else {
            log.warn "Brake & Go Back time INVALID (between 0 and 15) -> $danaBrakeGoBack seconds"
        }
    }

    if (danaTurnGo != null) {
        if (danaTurnGo) {
            log.info "Enabling Turn & Go"
        } else {
            log.info "Disabling Turn & Go"
        }

        cmds << zwave.configurationV1.configurationSet(parameterNumber: 9, configurationValue: [danaTurnGo ? 1 : 0])
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 9)
    }

    if (danaTurnSpeed as Integer) {
        if ((danaTurnSpeed as Integer) >=1 && (danaTurnSpeed as Integer) <= 5) {
            log.info "Setting speed to ${(danaTurnSpeed as Integer)}"

            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, configurationValue: [(danaTurnSpeed as Integer)])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        } else {
            log.warn "Turn speed INVALID (between 1 and 5) -> ${(danaTurnSpeed as Integer)}"
        }
    }

    cmds ? secureSequence(cmds, 5000) : null
}

def activateSmoke(String msg) {
    log.debug "$device.displayName: Activating smoke alarm sensor"
    sendEvent([ name: "smoke", value: "detected",  descriptionText: msg, displayed: true ])
}

def deactivateSmoke() {
    log.debug "$device.displayName: Deactivating smoke alarm sensor" 
    sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Deactivating smoke/fire alarm sensor", displayed: true ])
}

def resetSmoke() {
    log.debug "$device.displayName: Resetting smoke alarm sensor" 
    sendEvent([ name: "smoke", value: "clear",  descriptionText: "$device.displayName: Resetting smoke/fire alarm sensor", displayed: true ])
}

def activateMotion(String msg) {
    log.debug "$device.displayName: Activating door tampering activity sensor" 
    sendEvent([ name: "motion", value: "active",  descriptionText: msg, displayed: true ])
}

def deactivateMotion() {
    log.debug "$device.displayName: Deactivating door tampering activity sensor" 
    sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Deactivating door tampering activity sensor", displayed: true ])
}

def resetMotion() {
    log.debug "$device.displayName: Resetting door tampering activity sensor" 
    sendEvent([ name: "motion", value: "inactive",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
    sendEvent([ name: "tamper", value: "clear",  descriptionText: "$device.displayName: Resetting door tampering activity sensor", displayed: true ])
}

def setState(String position, String msg) {
    log.debug "$device.displayName: Setting door sensor: $position" 
    sendEvent([ name: "contact", value: position, descriptionText: msg ])
    sendEvent([ name: "contactX", value: position, displayed: false ])
}

def resetState() {
    log.debug "$device.displayName: Resetting door closed sensor" 
    sendEvent([ name: "contact", value: "closed", descriptionText: "$device.displayName Resetting door sensor as closed", displayed: true ])
    sendEvent([ name: "contactX", value: "unknown", displayed: false ])
}

def reLocked() {
    log.debug "$device.displayName: Sending lock door notification as a follow up the unlocked event for the non motorized deadbolt" 
    def map = [ name: "lock", value: "locked", method: "auto", displayed: true ]
    sendEvent(map)
}

// Dummy code for enabling switch interface on lock (uncomment the capability lock to use this)
def on() {
    lock()
}

def off() {
    unlock()
}

/**
 * Generic function for reading code Slot ID from AlarmReport command
 * @param cmd: The AlarmReport command
 * @return user code slot id
 */
def readCodeSlotId(physicalgraph.zwave.commands.alarmv2.AlarmReport cmd) {
	def codeID
	if(cmd.numberOfEventParameters == 1) {
		codeID = cmd.eventParameter[0]
	} else if(cmd.numberOfEventParameters >= 3) { // Yale doesn't follow Z-Wave specs and eventParameter contains user slot in 3rd byte e.g.: user 2 reported as [99, 3, 2, 1]
		codeID = cmd.eventParameter[2]
	} else {
		codeID = cmd.alarmLevel
	}

    codeID = correctLockCode(codeID)
    
	return codeID
}

// Make lock specific corrections to the User CodeID
private correctLockCode(codeID) {
    if (isYaleLock()) {
        codeID = (codeID > 249 ? 0 : codeID) // Yale locks master code returns 251 and 0 and specs allow code upto 0xF9
    }
    
    if (isIDLock()) {
        if (codeID >= 60) { // 60-109 are keypad PIN users
            codeID = codeID - (59 + (isIDLock101() ? 2 : 0)) // First keypad user is slot 3 for ST for IDLock 101 (1 is master and 2 is service) and slot 1 for IDLock 150
        } else if (codeID >= 10) { // 10-59 are RFID users
            codeID = codeID - 9
        } else if (!isIDLock101() && (codeID == 1 || codeID == 2)) { // slot 1 is master and slot 2 is service (remotely programmable), report them as master for non IDLock 101
            codeID = 0 // Report as master
        } else if (codeID == 0) { // If it's 0 then it's a remote unlock from the mobile, report it as null
            codeID = null
        }
    }
    
	return codeID
}

/**
 * Returns true if this lock generates door lock operation report before alarm report, false otherwise
 * @return true if this lock generates door lock operation report before alarm report, false otherwise
 */
def generatesDoorLockOperationReportBeforeAlarmReport() {
	//Fix for ICP-2367, ICP-2366
    if(isYaleLock() && (
        ("0007" == zwaveInfo.prod && "0001" == zwaveInfo.model) ||
        ("6600" == zwaveInfo.prod && "0002" == zwaveInfo.model) )) {
        //Yale Keyless Connected Smart Door Lock
        return true
	}
	return false
}

// NOTE: There appears to be a bug with the hub pairing where the zwInfo shows 0000 for mfr, prod and model. Until that is fixed use state.MSR as it is queried from the lock
/**
 * Utility function to check if the lock manufacturer is Schlage
 *
 * @return true if the lock manufacturer is Schlage, else false
 */
def isSchlageLock() {
	if (state.MSR?.startsWith("003B")) {
		if("Schlage" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Schlage")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Kwikset
 *
 * @return true if the lock manufacturer is Kwikset, else false
 */
def isKwiksetLock() {
	if (state.MSR?.startsWith("0090")) {
		if("Kwikset" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Kwikset")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Yale
 *
 * @return true if the lock manufacturer is Yale, else false
 */
def isYaleLock() {
	if (state.MSR?.startsWith("0129") || state.MSR?.startsWith("0109")) {
		if("Yale" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Yale")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Danalock (type V2)
 *
 * @return true if the lock manufacturer is Danalock type V2, else false
 */
def isDanaLockV2() {
	if (state.MSR?.startsWith("010E-0008")) {
		if("Danalock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Danalock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Danalock (type V3)
 *
 * @return true if the lock manufacturer is Danalock type V3, else false
 */
def isDanaLockV3() {
	if (state.MSR?.startsWith("010E-0009")) {
		if("Danalock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Danalock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is August
 *
 * @return true if the lock manufacturer is August, else false
 */
def isAugustLock() {
	if (state.MSR?.startsWith("033F")) {
		if("August" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "August")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is IDLock
 *
 * @return true if the lock manufacturer is IDLock, else false
 */
def isIDLock() {
	return (isIDLock101() || isIDLock150())
}

private isIDLock101() { // IDLock 101 model
	if (state.MSR?.startsWith("0230")) {
		if("IDLock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "IDLock")
		}
		return true
	}
	return false
}

def isIDLock150() { // IDLock 150 model
	if (state.MSR?.startsWith("0373")) {
		if("IDLock" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "IDLock")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the keypad manufacturer is Locstar
 *
 * @return true if the keypad manufacturer is Locstar, else false
 */
def isLocstarLock() {
	if (state.MSR?.startsWith("015e")) {
		if("Locstar" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Locstar")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is Samsung
 *
 * @return true if the lock manufacturer is Samsung, else false
 */
def isSamsungLock() {
	if (zwaveInfo?.mfr == "022E" || zwaveInfo?.mfr == "032F") { // Called from installed(), MSR may not exist yet
		if("Samsung" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Samsung")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the lock manufacturer is KeyWe (Gaurdtec Inc)
 *
 * @return true if the lock manufacturer is KeyWe, else false
 */
def isKeyWeLock() {
	if (zwaveInfo?.mfr == "037B") { // Called from installed(), MSR may not exist yet
		if("Guardtec Inc." != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Guardtec Inc.")
		}
		return true
	}
	return false
}

/**
 * Utility function to check if the keypad manufacturer is Popp
 *
 * @return true if the keypad manufacturer is Popp, else false
 */
def isPoppKeypad() {
	if (state.MSR?.startsWith("0154")) {
		if("Popp" != getDataValue("manufacturer")) {
			updateDataValue("manufacturer", "Popp")
		}
		return true
	}
	return false
}

/**
 * Utility function to convert a z-wave number value into a integer array
 */
private paramValue(value, bytes) {
    if (value == null || !(value instanceof Number)) {
        return null
    }

    //log.trace "Param value: $value, $bytes"

    List<Integer> ret = [] // We start with a Integer list and then convert to array (since arrays are fixed in size)
    for (int i=0; i<bytes; i++) {
        ret = [(((value as Long) >> (i*8)) & 0xFF) as Integer] + ret
    }

    //log.debug ret as Integer[]

    return ret as Integer[] // We need an integer array
}

/**
 * Utility function to convert a z-wave byte array into a number (long) value
 */
private reverseValue(value) {
    if (!value || !List.isCase(value)) {
        return null
    }

    //log.trace "Reverse value: $value, $bytes"

    Long ret = 0
    for (int i=0; i<value.size(); i++) {
        ret |= ((((value[i] as Integer) & 0xFF) as Long) << ((value.size() - 1 - i) * 8)) as Long
    }

    //log.debug ret

    return ret
}

private getDanalockV3ParamMap(value = null) {
    [
        "TurnAndGo": 			[ Param: 1, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Twist Assist
        "BrakeAndGo": 			[ Param: 2, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Hold and release
        "Async": 				[ Param: 3, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Blocked 2 Blocked
        "BleTempAllowTimer": 	[ Param: 4, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
        "BleAlwaysAllowed": 	[ Param: 5, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
        "AutoLock": 			[ Param: 6, Size: 4, Default: 0, Min: 0, Max: 2147483647, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
    ]
}

private getSchlageParamMap(value = null) {
    [
        "CodeLength": 			[ Param: 16, Size: 1, Default: 4, Min: 4, Max: 8, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it },
    ]
}

private getSamsungParamMap(value = null) {
    [
        "PrivacyMode": 			[ Param: 2, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ],
    ]
}

private getPoppParamMap(value = null) {
    [
        "LockSecureTimeout": 	[ Param: 1, Size: 1, Default: 3, Min: 0, Max: 127, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Association group 2 lock
        "RingOffTimeout": 		[ Param: 2, Size: 1, Default: 3, Min: 3, Max: 127, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Association group 3 ring
        "ReportUserCodes": 		[ Param: 5, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ], // Send user codes instead of scene ID 20
        "Buzzer": 				[ Param: 6, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ],
    ]
}

private getIdLockParamMap(value = null) {
    [
        "DoorLockMode": 		[ Param: 1, Size: 1, Default: 1, Min: 0, Max: 3, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // AutoLock and Away
        "DoorHingeLeft": 		[ Param: 3, Size: 1, Default: 0, Enabled: 1, Disabled: 0 ], // Right or left door hinge
        "AudioVolumeLevel": 	[ Param: 4, Size: 1, Default: 5, Min: 1, Max: 6, Value: reverseValue(value) ].with { put('ParamValue', paramValue(value, get('Size'))); it }, // Audio volume level, 0 is disabled, range is from 1 to 6
        "RelockMode": 			[ Param: 5, Size: 1, Default: 1, Enabled: 1, Disabled: 0 ], // Relock mode
    ]
}

// THIS IS THE END OF THE FILE

