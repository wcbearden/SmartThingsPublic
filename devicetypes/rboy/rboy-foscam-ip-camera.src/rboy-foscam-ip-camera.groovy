/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "04.03.00"
}

/**
 * Foscam/Tenvis IP Camera
 *
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 * Change log:
 * 2018-02-20 - (v04.03.00) Use Flip and Mirror status from Camera instead of having the user define them
 * 2018-02-08 - (v04.02.01) Added support for default/custom Ambarella detection area
 * 2017-12-07 - (v04.02.00) Fixed broken ST aysnc http for images and patch for ST blocking Google DNS name resolution
 * 2017-11-01 - (v04.01.00) Added support for sound detection sensitivity level and fixed sound detection on SD cameras
 * 2017-10-25 - (v04.00.00) Moved to callback for hubaction so that IP address can be changed on Camera and getting ready for auto discovery
 * 2017-10-11 - (v03.05.00) Added support for blank passwords. Added command 'center' and corner controls updated GUI, fixed issue with mirror+flip for SD cameras, added support for audio for SD cameras, added support for external IP address for live streaming, added support for automatic detection of presets and upto 6 presets, added support for camera fixed presets and cruises
 * 2017-8-28 - (v03.04.06) Show errors in device events
 * 2017-7-26 - (v03.04.05) Ignore any http(s) in the address field
 * 2017-5-4 - (v03.04.04) Update UI colors to match ST recommendation
 * 2017-2-1 - (v3.4.4) Clean up and support for retrieving image from S3
 * 2017-1-31 - (v3.4.3) Fix for change in ST platform snapshot API
 * 2017-1-23 - (v3.4.2) Disabled capability "Alarm" to avoid confusion, fixed take picture due to changes in the ST platform API's
 * 2017-1-14 - (v3.4.0) Added support for PIR and Motion options and the Amba Chipset/C2, R2, FI9900P camera, added support for cloud uploading, added support for showing error in communication with camera
 * 2016-12-2 - Fixed issue with password special characters in RTSP streams
 * 2016-11-30 - Improved text description
 * 2016-11-22 - Fixed issue with DNS service not working
 * 2016-11-5 - Added support for code version reporting
 * 2016-10-24 - Improved rate limit to block runaway loops, added ability to check for updates
 * 2016-10-7 - Rate limit number of pictures taken to 20 per 60 seconds on request from ST staff
 * 2016-9-6 - Added support for sound detection and clarified setup settings
 * 2016-7-26 - Clarified import of JsonSlurper
 * 2016-7-17 - Clarified IP input is hostname and not URL
 * 2016-7-5 - Clarification, hostnames are only for public DNS hostnames not local LAN
 * 2016-5-24 - Invoke refresh if user has not initialized camera after initial install and started video streaming
 * 2016-5-24 - Disabled imageDataJpeg attribute and storage for now on ST's request
 * 2016-5-24 - Comment out the updated() function since it's causing random issues with some users and being called randomly
 * 2016-5-17 - Clarified RTSP defaults in preferences
 * 2016-4-29 - Take care of bad camera firmware creating malformed XML strings
 * 2016-4-28 - Optimized layout of UI and button for video streaming
 * 2016-4-25 - Only enable mainStream h.264 (but activate subStream MJPEG for SmartTiles) for now since subStream MJPEG has issues with compatibility with ST Phone and subStream h.264 will break SmartTiles
 * 2016-4-23 - Summary is the default tile to show the motion detection on / off in the list of things
 * 2016-4-23 - Added separate RTSP port for C1 and other HD cameras, fix for switching profiles
 * 2016-4-23 - Fix for special characters in the password, fix for changing profiles
 * 2016-4-22 - Provided an option for enabling MJPEG cameras which also supports SmartTiles
 * 2016-4-19 - Added support for Video streaming for HD and SD cameras with Hi and Low res stream options
 * 2016-4-12 - Allow for no password in login (not a recommended practice but allow for it)
 * 2016-4-2 - Updated color for Auto LED off to light blue
 * 2016-4-2 - Fix for left/right/up/down direction when using HDCameras and Flip/Mirror (camera auto compensates)
 * 2016-4-2 - Changed message on motion detection to Motion instead of Alarm to emulate a motion sensor (and blue color)
 * 2016-3-15 - Changed imageDataJpeg to a Base64 string instead of UTF-8 to make it compatible with SmartTiles
 * 2016-3-15 - Fixed updated function
 * 2016-3-12 - Added support for imageDataJpeg attribute to report the JPEG picture as a UTF-8 String
 * 2016-2-28 - When using public hostnames don't convert to public IP, support for reverse proxies
 * 2016-2-14 - Removed unnecessary notifications from activity log
 * 2016-2-6 - Fixed refresh on configuration
 * 2016-2-2 - Add initialization on settings update
 * 2016-1-13 - Fix for "Content is not allowed in prolog" error (due to BOM) in older SD cameras
 * 2016-1-6 - Added option to manually enter detection area in the settings (no leading or trailing & required)
 * 2016-1-2 - Improved layout of buttons
 * 2015-10-11 - Added support to check for SD camera wrong username/password authorization errors
 * 2015-10-3 - Added support to fallback and retry if httpGet fails with hubAction
 * 2015-10-2 - Improve support for public ip address and improved speed of response for picture taking
 * 2015-9-30 - Fixed issue with special characters not working in username and password and preset names
 * 2015-9-30 - Improved settings explanation, added message for error responses from camera
 * 2015-9-19 - Added support for MultiAttribute Tiles
 * 2015-9-19 - Check for invalid IP Address or port and other settings
 * 2015-9-1 - Improved callback motion status update after 10 seconds
 * 2015-8-27 - Added option to reduce light sensitivity for SD cameras
 * 2015-8-24 - Fine tune movements of cameras and communication delays
 * 2015-8-24 - Fix for phantom alarm when turning on sometimes left over from previous alarm
 * 2015-8-23 - Fix for Push notification recurring alarm and improved reliability for SD Camera notifications
 * 2015-8-23 - Enabled support for Push notifications for SD cameras
 * 2015-8-23 - Removed attributes ledState and ledMode and converted to state variables
 * 2015-8-23 - Added support for SD Camera Poll Alarm notifications (push doesn't always work due to 128 character URL limit)
 * 2015-8-23 - Added support for eMail, Motion Sensitivity levels and Snap picture on motion alert for SD cameras
 * 2015-8-22 - Bugfixes for SD Foscam (MJPEG series likes 9810)
 * 2015-8-14 - Added support for Mirror and Flip for SD cameras Video orientation
 * 2015-8-14 - Added support for SD Camera Alarm push notifications
 * 2015-8-13 - Alarm notification for SD cameras is not supported yet, only for HD cameras
 * 2015-8-13 - Fixed the rearm interval to 15 seconds because the ST platform is too slow to communicate the camera and may miss the motion alarm notification
 * 2015-6-21 - Fixed issue with refresh not working
 * 2015-6-21 - Added support for mirroring/Flipping for HD cameras and support for video mirroring/flipping
 * 2015-6-19 - Added attributes ledState and ledMode to definitions
 * 2015-6-18 - Fix for tile names not being restored after pressing
 * 2015-6-17 - Added support for Motion Sensor to report motion - to be used in conjunction with the Foscam Motion Alarm Monitor since we can't poll from device code
 * 2015-6-17 - Enhanced reporting status dynamically, improved communicated reliablility, reduced verbosity of activity logs
 * 2015-6-17 - Added support for getting LED on/off status, simplified LED icons
 * 2015-6-17 - Fixed issue with HD camera's not working due to ST platform changes
 * 2015-3-28 - Fixed missing command siren and both for alarm capability, temp fix for android carousel hang, fixed issue with preset and cruisemap names breaking on android
 * 2015-2-22 - Fix for Alarm and Switch not being updated
 * 2015-2-4 - Presets show names
 * 2015-1-29 - Added options for configuring eMail, local ringer alarm, taking pictures and recording videos for motion detection
 * 2015-1-20 - Cruisemaps now show the names
 * 2015-1-20 - Added support for hostnames (public) instead of ipaddress for device
 * 2015-1-19 - Turning on the strobe function also takes a picture
 * 2015-1-19 - Support configuring motion alarm snap interval and motion sensitivity, added support for using as an Alarm and Switch/Relay Switch to enable monitoring
 */
 
metadata {
	definition (name: "RBoy Foscam IP Camera", namespace: "rboy", author: "RBoy Apps") {
		capability "Polling"
		capability "Image Capture"
        capability "Relay Switch"
        capability "Switch"
        capability "Refresh"
        capability "Motion Sensor"
        capability "Sensor"
        capability "Video Camera"
        capability "Video Capture"
        capability "Configuration"
        //capability "Alarm" // Enable this if you want to use use the Camera through the Alarm action to take a picture and turn on monitoring
        
        attribute "alarmStatus", "string"
        attribute "ledStatus", "string"
        attribute "hubactionMode", "string"
        attribute "presetTop", "string"
        attribute "presetBottom", "string"
        attribute "presetLeft", "string"
        attribute "presetRight", "string"
        attribute "preset1", "string"
        attribute "preset2", "string"
        attribute "preset3", "string"
        attribute "preset4", "string"
        attribute "preset5", "string"
        attribute "preset6", "string"
        attribute "mirrorStatus", "number"
        attribute "flipStatus", "number"
        attribute "cameraType", "string"
        attribute "alarmNotifyType", "string"
        //attribute "imageDataJpeg", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"
    
		command "alarmOn"
		command "alarmOff"
		command "toggleAlarm"

		command "toggleLED"
		command "ledOn"
		command "ledOff"
		command "ledAuto"
        
		command "left"
		command "right"
		command "up"
		command "down"
        command "center"
        command "leftDown"
        command "leftUp"
        command "rightDown"
        command "rightUp"
        
		command "horizontalCruise"
		command "verticalCruise"
		command "stopCruise"
        
		command "preset1"
		command "preset2"
		command "preset3"
		command "preset4"
		command "preset5"
		command "preset6"
        command "presetTop"
        command "presetBottom"
        command "presetLeft"
        command "presetRight"
        
        command "reboot"
        command "checkMotionStatus"
        command "registerMotionCallback", ["string"]
        command "deRegisterMotionCallback"
        command "motionCallbackNotify"
        command "startVideo"
        command "setHiRes"
        command "setLowRes"
	}
    
    // NOTE: Changes in preferences defaultValues: true (bool) should also be updated in the Foscam Camera Manager getNewConfiguredCameras()
    preferences {
        input title: "", description: "Foscam Device Handler v${clientVersion()}", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("ip", "string", title:"Camera IP address/Public hostname", description: "Camera IP address or DNS hostname", required: true, displayDuringSetup: true)
        input("port", "number", title:"Camera port", description: "Camera port", defaultValue: "88" , required: false, displayDuringSetup: true) // required false for now due to bug in ST Android app requiring minimum 3 digits for a  number inputs for some tablets
        input("username", "string", title:"Camera Administrator username (case sensitive)", description: "Camera Administrative rights username (case sensitive)", required: true, displayDuringSetup: true)
        input("password", "password", title:"Camera password (case sensitive)", description: "Camera password (case sensitive)", required: false, displayDuringSetup: true)
        input("hdcamera", "bool", title:"Enable this if the camera is a HD model (720p or higher)?", description: "HD camera", required: false, displayDuringSetup: true)
        input("cameraModel", "enum", title:"Select your camera model", multiple: false, defaultValue: "Others", options: ["Others":"Other Foscam","Amba":"C2/R2/R4/FI9900P"], description: "Select Other Foscam if your camera model isn't listed here", required: true, displayDuringSetup: true)
        
        input title: "", description: "If your camera supports Onvif (under Network in the Foscam web settings), enable it and enter the RTSP port here for live streaming (otherwise it defaults to the Camera Port above). Most cameras that have Onvif/RTSP typically use port 554", displayDuringSetup: true, type: "paragraph", element: "paragraph", required: true
        input("rtspport", "number", title:"RTSP port", description: "RTSP port", required: false, displayDuringSetup: true)
        //input("mirror", "bool", title:"Mirror", description: "Mirror image? (Horizontal)?", required: false, displayDuringSetup: true)
        //input("flip", "bool", title:"Flip", description: "Flip image? (Vertical)?", required: false, displayDuringSetup: true)
        
        input title: "", description: "Configure the motion/sound detection features of the camera. NOTE: Sound detection is very sensitive on Foscam cameras", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("motionLevel", "enum", title:"Motion detection sensitivity level", multiple: false, defaultValue: "Medium", options: ["Lowest","Lower","Low","Medium","High"], description: "Alarm Motion Sensitivity Level", required: true, displayDuringSetup: true)
        input("soundAlarm", "bool", title:"Enable sound detection", description: "Enable alarm for sound detection", defaultValue: false, required: false, displayDuringSetup: true)
        input("soundLevel", "enum", title:"Sound detection sensitivity level", multiple: false, defaultValue: "Lowest", options: ["Lowest","Lower","Low","Medium","High"], description: "Alarm Sound Sensitivity Level", required: true, displayDuringSetup: true)
        input("motionEMail", "bool", title:"Intruder detected -> Send eMail", description: "Send e-Mail when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionSnap", "bool", title:"Intruder detected -> Take picture", description: "Take a picture when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRecord", "bool", title:"Intruder detected -> Record video (HD cameras only)", description: "Record a video when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRing", "bool", title:"Intruder detected -> Turn on built-in camera sound alarm (HD cameras only)", description: "Sound local ring alarm when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        //input("reArmInterval", "enum", title:"Intruder detected -> Re-Arm interval (HD cameras only)", multiple: false, defaultValue: "15s", options: ["5s","6s","7s","8s","9s","10s","11s","12s","13s","14s","15s"], description: "Alarm Motion Snap Interval in seconds", required: true, displayDuringSetup: true)
        
        input title: "", description: "Configure the following 2 options only if your camera supports enabling/disabling Video motion and (Human) PIR motion detection separately", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("motionAlarmEnable", "bool", title:"Enable video motion detection", description: "Enable camera video motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        input("pirAlarmEnable", "bool", title:"Enable PIR motion detection", description: "Enable human motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        
        input title: "", description: "Configure this to use live streaming from outside your home. This requires your router to have port forwarding configured correctly", displayDuringSetup: true, type: "paragraph", element: "paragraph", required: true
        input("externalIp", "string", title:"Router IP address/Public hostname", description: "External IP address or DNS hostname", required: false, displayDuringSetup: true)
        
        input title: "", description: "SmartTiles requires MJPEG streaming\nIf your HD camera supports MJPEG, enable this option to view the live stream in SmartTiles using this URL: http://IPADDRESS:PORT/cgi-bin/CGIStream.cgi?cmd=GetMJStream&usr=USERNAME&pwd=PASSWORD", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("mjpeg", "bool", title:"Enable MJPEG (HD cameras only)", description: "MJPEG Streaming", required: false, displayDuringSetup: true)
        input("lightCompensation", "bool", title:"Compensate for sudden light changes (SD cameras only)", description: "Reduce motion alarms due to sudden changes in light", defaultValue: true, required: false, displayDuringSetup: false)
        input("detectionArea", "string", title:"(Advanced) Enter the motion detection area parameters (leave empty if unsure)", description: "Enter the parameters to use for motion detection area without the leading or trailing &, leave blank for default full screen detection", required: false, displayDuringSetup: false)

        input title: "", description: "THESE SETTINGS ONLY APPLY TO THE NEW FOSCAM AMBARELLA CAMERAS (e.g. C2, R2, FI9900P)", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input("disableMotionDetect", "bool", title:"Disable motion detection", description: "Disable regular camera motion detection", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanMotionDetect", "bool", title:"Enable human detection", description: "Detect human presence", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanSensitivity", "number", title:"Human detection sensitivity", description: "Sensitivity for detecting humans", defaultValue: "100", range: "0..100", required: false, displayDuringSetup: false)
        input("humanCountEnable", "bool", title:"Enable people counting", description: "Count humans detected", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanBoxingEnable", "bool", title:"Enable bounding box", description: "Detect human boundaries", defaultValue: false, required: false, displayDuringSetup: false)
        input("uploadCloud", "bool", title:"Intruder detected -> Upload to cloud", description: "Upload picture and recording to Foscam cloud", defaultValue: false, required: false, displayDuringSetup: false)
        input("pushFoscamPhoneApp", "bool", title:"Intruder detected -> Push message to Foscam app", description: "Push notification to Foscam native phone app", defaultValue: false, required: false, displayDuringSetup: false)
	}

	tiles(scale: 2) {
		multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4){
			tileAttribute ("device.alarmStatus", key: "PRIMARY_CONTROL") {
              attributeState "off", label: "Detect Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState:"..."
              attributeState "on", label: "Detect On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#00a0dc", nextState:"..."
              attributeState "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#e86d13", nextState:"..."
              attributeState "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333", nextState:""
              attributeState "...", label: "...", action:"", nextState:"..."
            }
            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
                attributeState "...", label: "...", action:"", nextState:"..."
            }
        }
        
        multiAttributeTile(name: "videoPlayer", type: "videoPlayer", width: 6, height: 4) {
            tileAttribute("device.camera", key: "CAMERA_STATUS") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#79b821", defaultState: true)
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#ffffff")
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#F22000")
			}

			tileAttribute("device.errorMessage", key: "CAMERA_ERROR_MESSAGE") {
				attributeState("errorMessage", label: "", value: "", defaultState: true)
			}

			tileAttribute("device.camera", key: "PRIMARY_CONTROL") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", backgroundColor: "#79b821")
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", backgroundColor: "#ffffff", defaultState: true)
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", backgroundColor: "#F22000")
			}

            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
                attributeState "...", label: "...", action:"", nextState:"..."
            }

            tileAttribute("device.startLive", key: "START_LIVE") {
				attributeState("live", action: "startVideo", defaultState: true)
			}

			tileAttribute("device.stream", key: "STREAM_URL") {
				attributeState("activeURL", defaultState: true)
			}

			/*tileAttribute("device.profile", key: "STREAM_QUALITY") {
				attributeState("hi", label: "Hi-Res", action: "setHiRes", defaultState: true)
				attributeState("low", label: "Low-Res", action: "setLowRes")
			}*/ // TODO: No profiles for now, lowRes MJPEG is not 100% stable so only use hiRes for now

			/*tileAttribute("device.betaLogo", key: "BETA_LOGO") {
				attributeState("betaLogo", label: "", value: "", defaultState: true)
			}*/
		}
		
        standardTile("alarmStatusA", "device.alarmStatus", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
            state "off", label: "Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState:"...", defaultState: true
            state "on", label: "On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#00a0dc", nextState:"..."
            state "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#e86d13", nextState:"..."
            state "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333", nextState:""
            state "...", label: "...", action:"", nextState:"..."
        }
        
        carouselTile("cameraDetails", "device.image", width: 4, height: 2) { }

		standardTile("take", "device.image", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
			state "default", label: "Take", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState:"taking", defaultState: true
			state "image", label: "Take", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState:"taking"
			state "taking", label:'Taking', action: "", icon: "st.camera.take-photo", backgroundColor: "#53a7c0"
		}

        standardTile("ledStatus", "device.ledStatus", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
          state "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"...", defaultState: true
          state "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
          state "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
          state "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
          state "...", label: "...", action:"", nextState:"..."
        }

		standardTile("preset1", "device.preset1", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset1", icon: "", defaultState: true
		}

		standardTile("preset2", "device.preset2", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset2", icon: "", defaultState: true
		}

		standardTile("preset3", "device.preset3", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset3", icon: "", defaultState: true
		}
        
		standardTile("preset4", "device.preset4", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset4", icon: "", defaultState: true
		}
        
		standardTile("preset5", "device.preset5", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset5", icon: "", defaultState: true
		}
        
		standardTile("preset6", "device.preset6", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Preset ${currentValue}', action: "preset6", icon: "", defaultState: true
		}
        
		standardTile("presettop", "device.presetTop", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "topmost", label: 'Top Most', action: "presetTop", icon: "", defaultState: true
		}

		standardTile("presetbottom", "device.presetBottom", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "bottommost", label: 'Bottom Most', action: "presetBottom", icon: "", defaultState: true
		}

		standardTile("presetleft", "device.presetLeft", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "leftmost", label: 'Left Most', action: "presetLeft", icon: "", defaultState: true
		}

		standardTile("presetright", "device.presetRight", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: '', action: "", icon: "", defaultState: true
			state "rightmost", label: 'Right Most', action: "presetRight", icon: "", defaultState: true
		}

		standardTile("horizontalcruise", "device.horizontalcruise", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Horizontal Cruise', action: "horizontalCruise", icon: "", defaultState: true
		}

		standardTile("verticalcruise", "device.verticalCruise", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: 'Vertical Cruise', action: "verticalCruise", icon: "", defaultState: true
		}
 
 		standardTile("stopcruise", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "Stop Cruise", action: "stopCruise", icon: "", defaultState: true
		}

		standardTile("leftUp", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "leftUp", icon: "http://smartthings.rboyapps.com/images/arrowTopLeft.png", defaultState: true
		}

		standardTile("leftDown", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "leftDown", icon: "http://smartthings.rboyapps.com/images/arrowBottomLeft.png", defaultState: true
		}

		standardTile("rightUp", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "rightUp", icon: "http://smartthings.rboyapps.com/images/arrowTopRight.png", defaultState: true
		}

		standardTile("rightDown", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "rightDown", icon: "http://smartthings.rboyapps.com/images/arrowBottomRight.png", defaultState: true
		}

		standardTile("left", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "left", icon: "http://smartthings.rboyapps.com/images/arrowLeft.png", defaultState: true
		}

		standardTile("right", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "right", icon: "http://smartthings.rboyapps.com/images/arrowRight.png", defaultState: true
		}

		standardTile("up", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "up", icon: "http://smartthings.rboyapps.com/images/arrowTop.png", defaultState: true
		}

		standardTile("down", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "default", label: "", action: "down", icon: "http://smartthings.rboyapps.com/images/arrowBottom.png", defaultState: true
		}

		standardTile("center", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "default", label: "Center", action: "center", icon: "", defaultState: true
		}

        standardTile("refresh", "device.status", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
        	state "default", action:"refresh.refresh", icon:"st.secondary.refresh", defaultState: true
        }
        
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "default", label: "", action: "", icon: "", backgroundColor: "#FFFFFF", defaultState: true
        }
        
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "default", label: "", action: "", icon: "", backgroundColor: "#FFFFFF", defaultState: true
        }
        
        standardTile("reboot", "device.image", width: 1, height: 1, inactiveLabel: false, decoration: "flat") {
      		state "default", label: "reboot", action: "reboot", icon: "st.quirky.spotter.quirky-spotter-plugged", defaultState: true
    	}

        main "summary", "videoPlayer"
        details(["ledStatus", "refresh", "alarmStatusA", "cameraDetails", "take", "videoPlayer", "preset1", "preset2", "preset3", "preset4", "preset5", "preset6", "leftUp", "up", "rightUp", "horizontalcruise", "stopcruise", "verticalcruise", "left", "center", "right", "presetleft", "presettop", "presetright", "leftDown", "down", "rightDown", "blank", "presetbottom", "reboot"])
	}
}

import groovy.json.JsonSlurper
include 'asynchttp_v1'

// Milli seconds delay between sending commands
private int delayInterval() {
 return 800
}

def initialize() {
    log.trace "Initialize called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        response(refresh())
	} catch (e) {
		log.warn "initialize() threw $e"
	}
}

// TODO: For some users, BUG WITH SMARTTHINGS PLATFORM, EVERYTIME A SMARTAPP CALLS A DEVICE FUNCTION, THIS UPDATED FUNCTION IS ALSO CALLED!!! IT ALSO CAUSES RANDOM ISSUES LIKE EVENT STATE BEING LOST FOR SOME USERS
def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        response(refresh()) // Get the updates and configure the video streams
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

//START VIDEO
// Thank you for the tip @ahndee
mappings {
    path("/getInHomeURL") {
        action:
            [GET: "getInHomeURL"]
    }
    
    path("/getOutHomeURL") {
        action:
            [GET: "getOutHomeURL"]
    }
}

def getInHomeURL() {
    log.trace "Called getInHomeURL, returning $state.uri"
    state.uri ? [InHomeURL: state.uri] : null // return null if it's not initialized otherwise ST app crashes
}

def getOutHomeURL() {
    log.trace "Called getOutHomeURL, returning $state.uriOut"
    state.uriOut ? [OutHomeURL: state.uriOut] : null // return null if it's not initialized otherwise ST app crashes
}

def setHiRes() {
    log.debug "Setting hi resolution stream"
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    def cleanIPOut = (externalIp ?: ip).toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    if (hdcamera) {
        log.debug "Enabling HiRes Stream type 0 for HD Camera"
        hubGet("cmd=setMainVideoStreamType&streamType=0") // TODO: Should we always use stream 0?
        
        log.trace "Using h.264 main stream for high bitrate streaming"
        state.uri = "rtsp://${(username)}:${(password?:"")}@${cleanIP}:${rtspport ?: port}/videoMain" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
        state.uriOut = "rtsp://${(username)}:${(password?:"")}@${cleanIPOut}:${rtspport ?: port}/videoMain" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
    } else {
        log.trace "Setting up high resolution stream for SD camera" // Apple Audio can be set via videostream.asf, videostream.cgi only provides video with no audio
        state.uri = "http://${cleanIP}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=32" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
        state.uriOut = "http://${cleanIPOut}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=32" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "hi", displayed: false)
}

private void setSubStreamingMode(mjpegEnable) {
    log.debug "Setting sub streaming mode for Camera (MJPEG mode enables SmartTiles compatibility) : ${mjpegEnable ? "MJPEG" : "h.264"}"
    hubGet("cmd=setSubStreamFormat&format=" + (mjpegEnable ? "1" : "0")) // 1 for MJPEG, 0 for H.264 stream http://foscam.us/forum/how-to-fetch-snapshots-and-mjpeg-stream-on-hd-cameras-t4328.html
}

def setLowRes() {
    log.debug "Setting low resolution stream"
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    def cleanIPOut = (externalIp ?: ip).toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    if (hdcamera) { // The newer HD cameras can operate as MPEG or h.264
        setSubStreamingMode(mjpeg) // Configure h.264 or MJPEG for sub streaming video. MJPEG required for compatibility with SmartTiles
        
        if (mjpeg) {
            log.trace "Using MJPEG for low bitrate streaming"
            state.uri = "http://${cleanIP}:${port}" + "/cgi-bin/CGIStream.cgi?cmd=GetMJStream&" + "usr=${username}&pwd=${password?:""}" // Don't URL encode the password here since it doesn't seem to work for special characters like ! with this special Video Tile
            state.uriOut = "http://${cleanIPOut}:${port}" + "/cgi-bin/CGIStream.cgi?cmd=GetMJStream&" + "usr=${username}&pwd=${password?:""}" // Don't URL encode the password here since it doesn't seem to work for special characters like ! with this special Video Tile
        } else {
            log.trace "Using h.264 sub stream for low bitrate streaming"
            state.uri = "rtsp://${(username)}:${(password?:"")}@${cleanIP}:${rtspport ?: port}/videoSub" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
            state.uriOut = "rtsp://${(username)}:${(password?:"")}@${cleanIPOut}:${rtspport ?: port}/videoSub" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
        }
    } else { // Older SD cameras use MJPEG by default
        log.trace "Setting up low resolution stream for SD camera" // Apple Audio can be set via videostream.asf, videostream.cgi only provides video with no audio
        state.uri = "http://${cleanIP}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=8" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
        state.uriOut = "http://${cleanIPOut}:${port}" + "/videostream.asf?" + "user=${username}&pwd=${password?:""}" + "&resolution=8" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "low", displayed: false)
}

def startVideo() {
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default to hi res (since low res has issue with mjpeg)
	log.debug "Starting video streaming with ${hiRes ? "High" : "Low"} profile stream"

    log.trace "Fetching video from:\nInHome: ${state.uri}\nOutHome: ${state.uriOut}"
    
    if (!state.uri || !state.uriOut) {
        refresh() // Initialize the camera
    }
    
	def dataLiveVideo = [
		InHomeURL   : state.uri, // TODO: Only this appears to be used
		OutHomeURL  : state.uriOut, // ?
		ThumbnailURL: "http://cdn.device-icons.smartthings.com/camera/dlink-hdpan@2x.png",
		cookie      : [key: "key", value: "value"]
	]

    log.trace "Video settings: $dataLiveVideo"
    
	def event = [
		name           : "stream",
		value          : groovy.json.JsonOutput.toJson(dataLiveVideo).toString(),
		data		   : groovy.json.JsonOutput.toJson(dataLiveVideo),
		descriptionText: "Starting the live video stream",
		eventType      : "VIDEO",
		displayed      : false,
		isStateChange  : true
	]
    
	sendEvent(event)
}
//END START VIDEO

//TAKE PICTURE
def take() {
	log.debug("Taking Photo")
    if (rateLimitExceeded()) {
        log.warn "Too many pictures taken in too short a time, skipping request"
        return
    }
	sendEvent(name: "hubactionMode", value: "s3", displayed: false)
    if(hdcamera) {
		hubGet("cmd=snapPicture2")
    } else {
    	hubGet("/snapshot.cgi?")
    }
}
//END TAKE PICTURE

//SWITCH ACTIONS
def on() {
	log.debug "On requested, enabling monitoring"
    alarmOn()
}

def off() {
	log.debug "Off requested, disabling monitoring"
    alarmOff()
}
//END SWITCH ACTIONS

//ALARM ACTIONS
def both() {
	log.debug "Alarm both requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def siren() {
	log.debug "Alarm siren requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def strobe() {
	log.debug "Alarm strobe requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def toggleAlarm() {
	log.debug "Toggling Alarm"
	if(device.currentValue("alarmStatus") == "off") {
    	alarmOn()
  	} else {
    	alarmOff()
	}
}

def alarmOn() {
	log.debug "Enabling Alarm"

	if(hdcamera) {
        if (cameraModel == "Amba") {
            delayBetween([hubGet("cmd=setMotionDetectConfig1&isEnable=${disableMotionDetect ? "0" : "1"}&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&${getDetectionArea(detectionArea)}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), hubGet("cmd=setHumanDetectConfig&isEnable=${humanMotionDetect ? "1" : "0"}&sensitivity=${humanSensitivity ?: "100"}&isHumanCountEnable=${humanCountEnable ? "1" : "0"}&isHumanBoxingEnable=${humanBoxingEnable ? "1" : "0"}&linkage=${getAmbaMotionAlarmEvents()}&snapInterval=1&triggerInterval=${getReArmInterval("10s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), hubGet("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=${getSoundLevel(soundLevel)}&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), poll()], delayInterval())
        } else {
            delayBetween([hubGet("cmd=setMotionDetectConfig&isEnable=1&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&sensitivity=${getMotionLevel(motionLevel)}&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655&${getDetectionArea(detectionArea)}&1421696056773"), hubGet("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=${getSoundLevel(soundLevel)}&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), poll()], delayInterval())
        }
    } else {
    	delayBetween([hubGet("/set_alarm.cgi?motion_armed=1&motion_sensitivity=${getMotionLevel(motionLevel)}&motion_compensation=${lightCompensation ? "1" : "0"}&sounddetect_armed=${soundAlarm ? "1" : "0"}&sounddetect_sensitivity=${getSoundLevel(soundLevel)}&mail=${motionEMail ? "1" : "0"}&upload_interval=${motionSnap ? "1" : "0"}&"), poll()], delayInterval())
    }
}

def alarmOff() {
	log.debug "Disabling Alarm"

    if(hdcamera) {
        if (cameraModel == "Amba") {
            delayBetween([hubGet("cmd=setMotionDetectConfig1&isEnable=0"), hubGet("cmd=setHumanDetectConfig&isEnable=0"), hubGet("cmd=setAudioAlarmConfig&isEnable=0"), poll()], delayInterval())
        } else {
            delayBetween([hubGet("cmd=setMotionDetectConfig&isEnable=0"), hubGet("cmd=setAudioAlarmConfig&isEnable=0"), poll()], delayInterval())
        }
    } else {
    	delayBetween([hubGet("/set_alarm.cgi?motion_armed=0&sounddetect_armed=0&"), poll()], delayInterval())
    }
    
}
//END ALARM ACTIONS

//LED ACTIONS
//Toggle LED's
def toggleLED() {
	log.debug("Toggle LED")
    if(hdcamera) {
        if((device.currentValue("ledStatus") == "autoOn") || (device.currentValue("ledStatus") == "autoOff")) {
            ledOn()
        } else if(device.currentValue("ledStatus") == "on") {
            ledOff()
        } else {
            ledAuto()
        }
    } else {
        ledAuto() // There is no way to get current status of LED for SD Cameras to keep it in Auto all the time
    }
}

def ledOn() {
    log.debug("LED changed to: on")
    if(hdcamera) {
	    delayBetween([hubGet("cmd=setInfraLedConfig&mode=1"), hubGet("cmd=openInfraLed"), poll()], delayInterval())
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in autoOff mode
        sendEvent(name: "ledStatus", value: "autoOff", isStateChange: true, displayed: false) // Force state change to udpate tile from ...
    	delayBetween([hubGet("/decoder_control.cgi?command=95&"), poll()], delayInterval())
    }
}

def ledOff() {
    log.debug("LED changed to: off")
    if(hdcamera) {
    	delayBetween([hubGet("cmd=setInfraLedConfig&mode=1"), hubGet("cmd=closeInfraLed"), poll()], delayInterval())
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in off mode
        sendEvent(name: "ledStatus", value: "off", isStateChange: true, displayed: false) // Force state change to udpate tile from ...
    	delayBetween([hubGet("/decoder_control.cgi?command=94&"), poll()], delayInterval())
    }
}

def ledAuto() {
    log.debug("LED changed to: auto")
	if(hdcamera) {
		delayBetween([hubGet("cmd=setInfraLedConfig&mode=0"), poll()], delayInterval())
    } else {
        // The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in autoOff mode
        sendEvent(name: "ledStatus", value: "autoOff", isStateChange: true, displayed: false) // Force state change to udpate tile from ...
    	delayBetween([hubGet("/decoder_control.cgi?command=95&"), poll()], delayInterval())
    }
}
//END LED ACTIONS

//PRESET ACTIONS
def presetTop() {
	log.debug("Preset TopMost Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("TopMost")}"), poll()], delayInterval())
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetBottom() {
	log.debug("Preset BottomMost Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("BottomMost")}"), poll()], delayInterval())
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetRight() {
	log.debug("Preset RightMost Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("RightMost")}"), poll()], delayInterval())
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def presetLeft() {
	log.debug("Preset LeftMost Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode("LeftMost")}"), poll()], delayInterval())
    } else {
    	log.warn "Not supported for SD cameras"
    }
}

def preset1() {
	log.debug("Preset 1 Selected - ${device.currentValue("preset1")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset1"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=31&"), poll()], delayInterval())
    }
}

def preset2() {
	log.debug("Preset 2 Selected - ${device.currentValue("preset2")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset2"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=33&"), poll()], delayInterval())
    }
}

def preset3() {
	log.debug("Preset 3 Selected - ${device.currentValue("preset3")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset3"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=35&"), poll()], delayInterval())
    }
}

def preset4() {
	log.debug("Preset 4 Selected - ${device.currentValue("preset4")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset4"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=37&"), poll()], delayInterval())
    }
}

def preset5() {
	log.debug("Preset 5 Selected - ${device.currentValue("preset5")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset5"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=39&"), poll()], delayInterval())
    }
}

def preset6() {
	log.debug("Preset 6 Selected - ${device.currentValue("preset6")}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(device.currentValue("preset6"))}"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=41&"), poll()], delayInterval())
    }
}
//END PRESET ACTIONS

//CRUISE ACTIONS
def horizontalCruise() {
	log.debug("Horizontal Cruise Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzStartCruise&mapName=Horizontal"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=28&"), poll()], delayInterval())
    }
}

def verticalCruise() {
	log.debug("Vertical Cruise Selected")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzStartCruise&mapName=Vertical"), poll()], delayInterval())
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=26&"), poll()], delayInterval())
    }
}

def stopCruise() {
	log.debug("Stop Cruise")
	if(hdcamera) {
		hubGet("cmd=ptzStopRun")
    } else {
    	delayBetween([hubGet("/decoder_control.cgi?command=29&"), hubGet("/decoder_control.cgi?command=27&")], 200)
    }
}
//END CRUISE ACTIONS

//PTZ CONTROLS
private getSDPTZ() {
    [
        "LEFT_DOWN":93,
        "LEFT_UP":91,
        "RIGHT_DOWN":92,
        "RIGHT_UP":90,
        "LEFT":6,
        "RIGHT":4,
        "UP":0,
        "DOWN":2,
        "CENTER":25,
        "STOP":1,
    ]
}

def center() {
	if(hdcamera) {
        hubGet("cmd=ptzReset")
    } else {
        hubGet("/decoder_control.cgi?command=${SDPTZ.CENTER}&")
    }
}

def leftDown() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveBottomLeft"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        } else {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        }
    }
}

def leftUp() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveTopLeft"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        } else {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        }
    }
}

def left() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveLeft"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus")) {
	    	hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT}&onestep=1&")
        } else {
        	hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT}&onestep=1&")
        }
    }
}

def rightDown() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveBottomRight"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        } else {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        }
    }
}

def rightUp() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveTopRight"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(device.currentValue("mirrorStatus") && !device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
    	} else if(!device.currentValue("mirrorStatus") && device.currentValue("flipStatus")) {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_DOWN}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        } else {
            delayBetween([hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT_UP}&"), hubGet("/decoder_control.cgi?command=1&")], 1000)
        }
    }
}

def right() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveRight"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("mirrorStatus")) {
	    	hubGet("/decoder_control.cgi?command=${SDPTZ.LEFT}&onestep=1&")
        } else {
        	hubGet("/decoder_control.cgi?command=${SDPTZ.RIGHT}&onestep=1&")
        }
    }
}

def up() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveUp"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("flipStatus")) {
	    	hubGet("/decoder_control.cgi?command=${SDPTZ.DOWN}&onestep=1&")
        } else {
        	hubGet("/decoder_control.cgi?command=${SDPTZ.UP}&onestep=1&")
        }
    }
}

def down() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveDown"), hubGet("cmd=ptzStopRun")], 1000)
    } else {
    	if(device.currentValue("flipStatus")) {
    		hubGet("/decoder_control.cgi?command=${SDPTZ.UP}&onestep=1&")
        } else {
        	hubGet("/decoder_control.cgi?command=${SDPTZ.DOWN}&onestep=1&")
        }
    }
}
//END PTZ CONTROLS

//REBOOT
def reboot() {
	log.debug "Rebooting camera"
	if(hdcamera) {
		hubGet("cmd=rebootSystem")
    } else {
    	hubGet("/reboot.cgi?&" + getLogin())
    }
}
//END REBOOT

def configure() {
    log.trace "Configuration called"
    
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default fall back hi resolution since low resolution has issues with mjpeg and ST app compatibility
	log.debug "Configuring video streaming for ${hiRes ? "High" : "Low"} Resolution stream"

    if (mjpeg && hdcamera) {
        log.debug "Enabling Camera MJPEG sub streaming mode for SmartTile compatibility"
        setSubStreamingMode(mjpeg)
    }
    
    if (hiRes) {
        setHiRes()
    } else {
        setLowRes()
    }
}

def refresh() {
	log.trace "Refresh called. Settings -> $settings"
    state.cameraHost = null // Reset it to force a lookup

    rateLimitExceeded("", true) // Reset rate allowance

    configure() // Configure the camera
	poll()
}

def poll() {
	log.trace "Poll called"

    // Send the events here and not in hubresponse since it causes the video stream to be interrupted
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Foscam Device Handler"]) // Save DH Name for parent app

    //Update the tiles names
    if(!hdcamera) // SD cameras has standard preset names
    {
        (1..6).each {
            sendEvent(name: "preset${it}", value: "${it}", displayed: false)
        }
    }
    sendEvent(name: "cameraType", value: "${hdcamera ? "HD" : "SD"}", displayed: false)
    sendEvent(name: "alarmNotifyType", value: "${hdcamera ? "Pull" : "Push"}", displayed: false) // Only SD camera support Push notifications

    def cmds = [] // we can only have one delayBetween, put them all together in the right order

	//Poll Motion Alarm Status and IR LED Mode and device status
    if (hdcamera) {
        // Get the device, LED and Mirror status first
        cmds << hubGet("cmd=getDevState") // Motion detection/alarm status
        cmds << hubGet("cmd=getInfraLedConfig")
        cmds << hubGet("cmd=getMirrorAndFlipSetting")
        cmds << hubGet("cmd=getPTZPresetPointList") // Get list of preset points
        //cmds << hubGet("cmd=getAudioAlarmConfig") // not required for now
        //cmds << hubGet("cmd=getMotionDetectConfig${cameraModel == "Amba" ? "1" : ""}") // not required for now, we have everything we need
        //if (cameraModel == "Amba") {
        	//cmds << hubGet("cmd=getHumanDetectConfig") // not required for now, we have everything we need
        //}

		/*// Enable/Disable Mirror - Use camera settings
        if (mirror && (device.currentValue("mirrorStatus") != 1)) {
            log.debug "Enabling video mirroring"
            cmds << hubGet("cmd=mirrorVideo&isMirror=1")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        } else if (!mirror && (device.currentValue("mirrorStatus") != 0)) {
            log.debug "Disabling video mirroring"
            cmds << hubGet("cmd=mirrorVideo&isMirror=0")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != 1)) {
            log.debug "Enabling video flipping"
            cmds << hubGet("cmd=flipVideo&isFlip=1")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        } else if (!flip && (device.currentValue("flipStatus") != 0)) {
            log.debug "Disabling video flipping"
            cmds << hubGet("cmd=flipVideo&isFlip=0")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }*/
	} else { // SD Camera
        // Get all the settings first
        cmds << hubGet("/get_status.cgi?") // Motion Detection Status
        cmds << hubGet("/get_params.cgi?") // Alarm Status
    	cmds << hubGet("/get_camera_params.cgi?") // Mirror and flip status

		/*// Enable/Disable Mirror - Use camera settings
        def setMirrorFlip = false
        if (mirror && (device.currentValue("mirrorStatus") != 1)) {
            log.debug "Enabling video mirroring"
            setMirrorFlip = true
        } else if (!mirror && (device.currentValue("mirrorStatus") != 0)) {
            log.debug "Disabling video mirroring"
            setMirrorFlip = true
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != 1)) {
            log.debug "Enabling video flipping"
            setMirrorFlip = true
        } else if (!flip && (device.currentValue("flipStatus") != 0)) {
            log.debug "Disabling video flipping"
            setMirrorFlip = true
        }

		if (setMirrorFlip) {
            def value = 0
            if (mirror) {
                value |= 2
            }
            if (flip) {
                value |= 1
            }
            cmds << hubGet("/camera_control.cgi?param=5&value=${value}&")
			cmds << hubGet("/get_camera_params.cgi?")
        }*/
    }

    //log.trace "Executing -> ${cmds.inspect()}"
    delayBetween(cmds, delayInterval())
}

private getLogin() {
	if(hdcamera) {
    	return "usr=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password?:"")}&"
    }
    else {
    	return "user=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password?:"")}"
    }
}

private hubGet(def apiCommand) {
    def useIP // We can't use state.ipAddress since it will be updated here and state variables won't be committed until the function exits (so readback will not show the latest state)
    def cleanIP = ip.toLowerCase().replace("https://", "").replace("http://", "") // Sanitize the hostname/IP address, remove leading http(s)
    
    // ST has blocked access to Google DNS do don't convert hostname to IP for now, if we have a hostname/public IP use the server API else use local hubAction for local IP
    useIP = cleanIP
    
	/*// Check if we have a hostname and if so convert to IP Address
    //log.trace "Saved IP: $state.ipAddress, Saved Host: $state.cameraHost, User IP: $cleanIP"
    if (!state.ipAddress || (state.cameraHost != cleanIP)) { // check if the IP/Host has changed or we don't have an IP address
        if (!isIPAddress(cleanIP)) {
            //log.trace "Converting hostname $cleanIP to IP Address before continuing"
            def h2ip = convertHostnameToIPAddress(cleanIP)
            state.ipAddress = useIP = h2ip
            log.trace "Got IPAddress=${h2ip} for hostname=$cleanIP"
        } else {
            state.ipAddress = useIP = cleanIP
            log.trace "Using IPAddress=${cleanIP}"
        }
        state.cameraHost = cleanIP // We've completed the above successfully, cache it to improve performance
    } else {
        log.trace "Using cached IPAddress=${state.ipAddress}"
        useIP = state.ipAddress
    }
    
    if (!useIP) {
        log.error "ERROR: Unable to get usable IP address!!"
        return
    }*/
    
	//Setting Network Device Id (only required if we are not using hubAction callback)
    //log.trace "Using address: $useIP"
    if (isIPAddress(useIP)) {
        def iphex = convertIPtoHex(useIP)
        def porthex = convertPortToHex(port)
        if (device.deviceNetworkId != "$iphex:$porthex") { // We keep this up to date because the Foscam Camera Manager uses discovery to find new cameras based on LAN IP address and Port (dni)
            device.deviceNetworkId = "$iphex:$porthex"
            log.info "Device Network Id updated to ${iphex}:${porthex}"
        }
    } else {
        if (device.deviceNetworkId != "$useIP:$port") { // We keep this up to date because the Foscam Camera Manager uses discovery to find new cameras based on LAN IP address and Port (dni)
            device.deviceNetworkId = "$useIP:$port" // We need a unique DNI for any device so use the hostname and port combination for now (you can have multiple cameras on a host)
            log.info "Device Network Id updated to ${useIP}:${port}"
        }
    }

    def uri = ""
    if (hdcamera) {
    	uri = "/cgi-bin/CGIProxy.fcgi?" + getLogin() + apiCommand
	}
    else {
    	uri = apiCommand + getLogin()
    }
    
	boolean doHubAction = false
    if (!isIPAddress(useIP) || isPublicIPAddress(useIP)) { // If we are working with hostname or a public IP address then use httpGet from ST cloud to public IP, it's faster and more reliable (doesn't depend on loopback)
        try {
            // TODO: Choose between Async and Sync, Async is still BETA but doesn't block and timeout incase of an offline camera or bad IP
            if (device.currentValue("hubactionMode") == "s3") { // NOTE: Async is currently broken for JPEG images since it converts the response from the camera into a UTF-8 string which replaces non printable characters with EF BF BD (replacement character), so use sync for now
                // Sync blocking httpGet
                log.trace "Sending httpGet command -> http://${getHostAddress(cleanIP)}$uri"
                sendEvent(name: "hubactionMode", value: "local", displayed: false)
                httpGet("http://${getHostAddress(cleanIP)}$uri") { response -> parseHttpGetResponse(response) }
            } else {
                // Async non blocking httpGet
                log.trace "Sending Async httpGet command -> http://${getHostAddress(cleanIP)}$uri"
                asynchttp_v1.get(parseHttpGetAsyncResponse, [ uri: "http://${getHostAddress(cleanIP)}$uri" ])
            }
        } catch (Exception e) {
            log.error "Unable to connect to host ${getHostAddress(cleanIP)}, Error: $e"
            /* hubAction no longer works for public IP addresses, only private IP addresses
            if (isIPAddress(useIP)) { // Fallback only if it is an IP address
                log.debug "Falling back to hubAction and retrying command"
                doHubAction = true // lets fall back and retry, hubAction works for both private and public ip addresses
            }*/
        }
    } else { // If we are using local IP Address, use hubAction, the only way to communicate from hub to Camera.
    	doHubAction = true
    }
    
    if (doHubAction) {
        log.trace "Sending hubAction command -> http://${getHostAddress(useIP)}$uri"
        def hubAction = new physicalgraph.device.HubAction(
            method: "GET",
            path: uri,
            headers: [HOST:getHostAddress(useIP)],
            String dni = null, // Remove this when using device.deviceNetworkId
            [callback: callbackParse], // Remove this when using device.deviceNetworkId
        )

        // If we have a picture then extract it and store it and set the hubAction mode accordingly
        if (device.currentValue("hubactionMode") == "s3") {
            log.trace "Resetting hubActionMode to local"
            hubAction.options = [outputMsgToS3:true, callback: callbackParse] // Remove callback when using device.deviceNetworkId
            sendEvent(name: "hubactionMode", value: "local", displayed: false)
        }
        sendHubCommand(hubAction)
    }
}

void callbackParse(physicalgraph.device.HubResponse hubResponse) {
    log.trace "Received callback response from Camera"
    //log.debug "Response: ${hubResponse}\nDescription: ${hubResponse.description}\nBody: ${hubResponse.body}"
    
    if (hubResponse.description) {
    	parseResponse(hubResponse.description)
    } else {
        log.error "Received an invalid response from Camera or hub"
    }
}

def parseHttpGetAsyncResponse(response, data) {
    if (response.hasError()) {
        log.warn "Aysnc httpGet response has error: ${response.getErrorMessage()}"
    }
    log.trace "Received response from camera to async httpGet, headers=${response.headers}, status=${response.status}, warning=${response.warningMessages}, data=$data"
    parseHttpGetResponse(response)
}
    
def parseHttpGetResponse(response) {
    log.trace "Received response from camera to httpGet, headers=${(response.headers?.'Content-type' ?: response.headers?.'Content-Type')}, status=${response.status}" // TODO: Bug with ST Async httpGet, https://community.smartthings.com/t/asynchronous-http-beta-feedback-thread/60280/11?
    if (response.status == 200) {
        if((!response.headers && response.data) || (response.headers?.'Content-type' ?: response.headers?.'Content-Type')?.contains("image/jpeg")) { // If we have a picture store it directly (TODO: Bug with Async httpGet, the header is null for image data)
            if(response.data) {
                /*def sb = "" // Dump the first 50 bytes for debugging
                if (response.data instanceof String) {
                    response.data.take(50).getBytes().each { sb += String.format("%02X", (it & 0xff)) + " " }
                } else {
                    (0..50).each {
                        sb += String.format("%02X", (response.data.buf[it] & 0xff)) + " " // convert each byte to hex without converting to a string since it loses non printable data
                    }
                }
                log.warn sb*/

                def image = (response.data instanceof String) ? new ByteArrayInputStream(response.data.getBytes("US-ASCII")) : response.data // httpGet async returns String data where as httpGet synchronous returns a byte array input stream
                
                // Send the image to an App who wants to consume it via an event as a Base64 String - NOTE: Disabled for now since ST has put a limitation on this which is causing trouble with the carousel
                //def bytes = image.buf
                //log.debug "JPEG Data Size: ${bytes.size()}"
                //String str = bytes.encodeBase64()
                //sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)
                //sendEvent(name: "imageDataJpeg", value: "", displayed: false, isStateChange: false) // Wipe it clean so it empties any old data

                // Now save it to the S3 cloud, so this in the end since it removes the data from the object leaving it empty
                log.info "Saving picture to SmartThings"
                storeImage(getPictureName(), image)
            } else {
                log.warn "Received an empty response from camera, expecting a JPEG image"
            }
        } else if((response.headers?.'Content-type' ?: response.headers?.'Content-Type')?.contains("text/plain")) { // Otherwise process the camera response codes
            String body
            if (response.data instanceof java.io.StringReader) { // httpGet
                body = response.data.getText()
            } else { // httpGet Async
                body = response.data
            }
            //log.trace "httpGet -> ${body}"
            processResponse(body)
        } else {
            log.error "Unknown response from camera, no header"
        }
    } else {
        log.error "Error response from host ${getHostAddress(ip)}, HTTP Response code: $response.status"
    }
}

// This function is called when we are using hubAction with a networkDeviceId (not callback)
def parse(String description) {
	log.trace "Received response from Camera to hubAction"
    parseResponse(description)
}

private parseResponse(description){     
    def descMap = parseDescriptionAsMap(description)
    //log.trace "${descMap.inspect()}"
    
    // Check if its a picture and process it
	if (descMap["tempImageKey"]) {
		putImageInS3(descMap)
	} else if (descMap["headers"] && descMap["body"]) { // Otherwise check camera response
        def body = new String(descMap["body"].decodeBase64())
	    //log.trace "Body -> ${body}"
		processResponse(body)
	}
}

def parseDescriptionAsMap(description) {
	description.split(",").inject([:]) { map, param ->
		def nameAndValue = param.split(":")
		map += [(nameAndValue[0].trim()):nameAndValue[1].trim()]
	}
}

def putImageInS3(map) {
    //log.trace "${map.inspect()}"

    try {
        // Save image from S3 bucket to S3 device cloud
        log.info "Saving picture to SmartThings"
        def lastImageUrl
        state.lastImageS3Url = lastImageUrl = getPictureName()
        storeTemporaryImage(map.tempImageKey, lastImageUrl)

        // getState()/getData() - gets a map of the state variable
        // getZwave() - gets physicalgraph.zwave.Zwave object
        // getLog() - gets various log objects (trace, debug, info, warn, error, fatal)

        /*log.trace "Getting S3 image ${lastImageUrl}" // we cannot use state.lastImageS3Url because it was modified in this function and the value isn't committed until the function exits
        def image = getImage(lastImageUrl)
        log.trace "Got image\n$image"
        if(image)
        {
            // Send the image to an App who wants to consume it via an event as a Base64 String
            //def bytes = image.buf
            //log.debug "JPEG Data Size: ${bytes.size()}"
            //String str = bytes.encodeBase64()
            //sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)
            sendEvent(name: "imageDataJpeg", value: "", displayed: false, isStateChange: false) // Wipe it clean so it empties any old data

        } else {
            log.warn "No picture content, nothing to save"
        }*/
	}
	catch(Exception e) {
		log.error "Error processing image, Error: $e"
	}
}

// Process the response from the camera
private processResponse(String body) {
    //log.trace body
    if(hdcamera) {
        processHDResponse(body)
    } else {
        processSDResponse(body)
    }
}

private processHDResponse(body) {
    def statusVars = new XmlSlurper(false,false,true).parseText(body?.trim()?.replaceFirst("^([\\W]+)<","<")) // Some cameras create a malformed XML so ignore BOM's and extra characters before the start of the XML
    //log.trace "Vars -> ${statusVars}"

    // Check the result value for the command sent
    switch (statusVars.result) {
        case "0":
        //log.warn "Camera responded with result ${statusVars.result} -> ALL's GOOD, THIS IS JUST A DEBUG" // Do nothing, this is good!
        break

        case "-1":
        def logErr = "Camera responded with result ${statusVars.result} -> CGI request string format error, your Username or Password may contain invalid character. The only allowed special characters are ~!@^*()_"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-2":
        def logErr = "Camera responded with result ${statusVars.result} -> Invalid username or password. Check your Username and Password (BOTH are case sensitive)"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-3":
        def logErr = "Camera responded with result ${statusVars.result} -> Access denied. Make sure the Username you've entered has Administrative rights on the camera"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-4":
        def logErr = "Camera responded with result ${statusVars.result} -> CGI execution failed"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-5":
        def logErr = "Camera responded with result ${statusVars.result} -> Timeout"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-6":
        def logErr = "Camera responded with result ${statusVars.result} -> Reserved error"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-7":
        def logErr = "Camera responded with result ${statusVars.result} -> Unknown error"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        case "-8":
        def logErr = "Camera responded with result ${statusVars.result} -> Reserved error"
        log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break

        default:
            def logErr = "Camera responded with result ${statusVars.result} -> Unknown error"
            log.error logErr
        sendEvent(name: "alarmStatus", value: "error", descriptionText: logErr, displayed: true, isStateChange: true)
        break
    }

    // Get mirror and flip settings
    def flipS = "$statusVars.isFlip"
    def mirrorS = "$statusVars.isMirror"
    if (mirrorS?.trim() != "") {
        log.info "Polled: Mirror status $mirrorS"
        sendEvent(name: "mirrorStatus", value: mirrorS, displayed: false)
    }
    if (flipS?.trim() != "") {
        log.info "Polled: Flip status $flipS"
        sendEvent(name: "flipStatus", value: flipS, displayed: false)
    }

    //Get Motion Alarm Status
    def motionAlarmDetect = "$statusVars.motionDetectAlarm" // $statusVars.isEnable is used with getMotionDetectConfig
    def humanAlarmDetect = "$statusVars.humanDetectAlarmState" // Amba foscam (C2, R2, FI9900P)
    def soundAlarmDetect = "$statusVars.soundAlarm" // Sounds alarm
    //log.warn "motionAlarmDetect=$motionAlarmDetect, humanAlarmDetect=$humanAlarmDetect, soundAlarmDetect=$soundAlarmDetect"
    if(motionAlarmDetect == "2" || soundAlarmDetect == "2" || humanAlarmDetect == "2") {
        log.info("Polled: ${motionAlarmDetect == 2 ? "Motion" : (humanAlarmDetect == 2 ? "Human Motion" : "Sound Motion")} Alarm Alert!!")
        sendEvent(name: "alarmStatus", value: "alarm")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected ${motionAlarmDetect == 2 ? "motion" : (humanAlarmDetect == 2 ? "human motion" : "sound motion")}")
    } else if(motionAlarmDetect == "1" || soundAlarmDetect == "1" || humanAlarmDetect == "1") {
        log.info("Polled: ${motionAlarmDetect == 1 ? "Motion" : (humanAlarmDetect == 1 ? "Human Motion" : "Sound Motion")} Alarm On")
        sendEvent(name: "alarmStatus", value: "on")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName ${motionAlarmDetect == 1 ? "motion" : (humanAlarmDetect == 1 ? "human motion" : "sound motion")} stopped")
    } else if(motionAlarmDetect || soundAlarmDetect || humanAlarmDetect) {
        log.info("Polled: Motion Alarm Off")
        sendEvent(name: "alarmStatus", value: "off")
        sendEvent(name: "alarm", value: "off")
        sendEvent(name: "switch", value: "off")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion detection off")
    }

    // First get Get IR LED Status
    def ledS = "$statusVars.infraLedState"
    if(ledS == "1") {
        log.info("Polled: LED On")
        state.ledState = "on" // this is an internal variable to track the LED state
    } else if(ledS == "0") {
        log.info("Polled: LED Off")
        state.ledState = "off" // this is an internal variable to track the LED state
    }

    // Then Get IR LED Mode (we can't use state.ledMode since state variable is committed after the function exits and hence it's updated value won't be available until the next time)
    def ledM = "$statusVars.mode"
    if(ledM == "0") {
        log.info("Polled: LED Mode Auto")
    } else if(ledM == "1") {
        log.info("Polled: LED Mode Manual")
    }

    // Update LED Status
    if (state.ledState == "on") {
        if (ledM == "0") {
            log.trace "ledStatus autoOn"
            state.ledState = "reset"
            sendEvent(name: "ledStatus", value: "autoOn", displayed: false)
        } else if (ledM == "1") {
            log.trace "ledStatus on"
            state.ledState = "reset"
            sendEvent(name: "ledStatus", value: "on", displayed: false)
        }
    } else if (state.ledState == "off") {
        if (ledM == "0") {
            log.trace "ledStatus autoOff"
            state.ledState = "reset"
            sendEvent(name: "ledStatus", value: "autoOff", displayed: false)
        } else if (ledM == "1") {
            log.trace "ledStatus off"
            state.ledState = "reset"
            sendEvent(name: "ledStatus", value: "off", displayed: false)
        }
    }
    
    // Update Preset Points (first 4 (0-3) are fixed, they are TopMost, BottomMost, LeftMost, RightMost, we capture the next 6 custom presets
    if ("$statusVars.point0"?.trim()) { // Convert XML node to string and check if it isn't empty
        // Update standard presets
        log.trace "First 4 fixed presets -> $statusVars.point0, $statusVars.point1, $statusVars.point2, $statusVars.point3"
        sendEvent(name: "presetTop", value: "topmost", displayed: false)
        sendEvent(name: "presetBottom", value: "bottommost", displayed: false)
        sendEvent(name: "presetLeft", value: "leftmost", displayed: false)
        sendEvent(name: "presetRight", value: "rightmost", displayed: false)
        
        (4..9).each {
            def presetName = "${statusVars."point${it}"}"
            log.trace "Found preset ${it - 3} -> $presetName"
            sendEvent(name: "preset${it - 3}", value: "${presetName ?: (it - 3)}", displayed: false)
        }
    }
}

private processSDResponse(body) {
    /*if (body?.length() > 2000) { // Doesn't always fit in one line so split it
        log.trace body.substring(0,2000)
        log.trace body.substring(2000)
    } else {
        log.trace body
    }*/
    
    // Check for an error in the result value of the command sent
    if (body.find("401 Unauthorized")) {
        log.error "Camera responded with an 401 Unauthorized error. Check you Username and Password (BOTH are case sensitive). Error -> ${body}"
        sendEvent(name: "alarmStatus", value: "error", descriptionText: "Invalid username and password (BOTH are case sensitive)", displayed: true, isStateChange: true)
        return
    } else if (body.find("illegal params")) {
        log.error "Camera responded with an error. Likely caused by an invalid Username or Password, check you Username and Password (BOTH are case sensitive). Error -> ${body}"
        sendEvent(name: "alarmStatus", value: "error", descriptionText: "Camera responded with an error, check logs", displayed: true, isStateChange: true)
        return
    }

    // First get the status and save it in the state variable
    if(body.find("alarm_status=1")) { // Check for active alarm
        log.info("Polled: Motion Alarm Alert!!")
        state.sdAlarmStatus = "Alarm"
    } else if(body.find("alarm_status=0")) {
        state.sdAlarmStatus = "None"
    }

    // Next get the motion but we can't save it in the state variable since the state variable is committed only when the function exits and we need to use it below
    def sdAlarmArmed
    if(body.find("alarm_motion_armed=0")) {
        log.info("Polled: Motion Alarm Off")
        sdAlarmArmed = "Off"
    }
    else if(body.find("alarm_motion_armed=1")) { // only check for "on" status when alarm is not active
        log.info("Polled: Motion Alarm On")
        sdAlarmArmed = "On"
    }

    // Check our state now and update the events
    //log.trace "Motion: ${state.sdAlarmStatus}, Armed: ${sdAlarmArmed}"
    if (sdAlarmArmed == "Off") { // First priority, if we're in off state then turn it off
        log.trace "Motiom alarm off"
        sendEvent(name: "alarmStatus", value: "off")
        sendEvent(name: "alarm", value: "off")
        sendEvent(name: "switch", value: "off")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
        state.sdAlarmStatus = "None" // Since they are 2 different registers we can have have Alarm on but monitoring off, force Alarm off if monitoring is off
    } else if ((sdAlarmArmed == "On") && (state.sdAlarmStatus == "Alarm")) { // Next priority Alarm 
        log.trace "Motion alarm Alarmed"
        sendEvent(name: "alarmStatus", value: "alarm")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
    } else if ((sdAlarmArmed == "On") && (state.sdAlarmStatus == "None")) { // If not in alarm check for On
        log.trace "Motion alarm on"
        sendEvent(name: "alarmStatus", value: "on")
        sendEvent(name: "alarm", value: "both")
        sendEvent(name: "switch", value: "on")
        sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
    }

    if(body.find("alarm_http=0")) {
        log.info("Polled: Motion Alarm Callback Notification Disabled")
    } else if(body.find("alarm_http=1")) {
        def callbackURL = (body =~ ".*?alarm_http_url='(.*?)'")[0][1]
        log.info("Polled: Motion Alarm Callback Notification Enabled with URL $callbackURL")
    }

    // Get mirror and flip settings
    if (body.find("flip=0")) {
        log.info "Polled: Flip Status 0, Mirror Status 0"
        sendEvent(name: "mirrorStatus", value: 0, displayed: false)
        sendEvent(name: "flipStatus", value: 0, displayed: false)
    } else if (body.find("flip=1")) {
        log.info "Polled: Flip status 1, Mirror Status 0"
        sendEvent(name: "mirrorStatus", value: 0, displayed: false)
        sendEvent(name: "flipStatus", value: 1, displayed: false)
    } else if (body.find("flip=2")) {
        log.info "Polled: Flip status 0, Mirror status 1"
        sendEvent(name: "mirrorStatus", value: 1, displayed: false)
        sendEvent(name: "flipStatus", value: 0, displayed: false)
    } else if (body.find("flip=3")) {
        log.info "Polled: Flip status 1, Mirror status 1"
        sendEvent(name: "mirrorStatus", value: 1, displayed: false)
        sendEvent(name: "flipStatus", value: 1, displayed: false)
    }
}

def checkMotionStatus() {
	log.debug "Checking motion alarm status"

	//Poll Motion Alarm Status
    if (hdcamera) {
        hubGet("cmd=getDevState") // Motion/Alarm status
    } else {
    	delayBetween([hubGet("/get_status.cgi?"), hubGet("/get_params.cgi?")], delayInterval()) // Motion Detection Status, Alarm Status
    }
}

def registerMotionCallback(callbackURL)
{
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This cameras doesn't support callback URL, this should not be called"
    } else {
		log.debug "Registering motion detection callback URL -> $callbackURL"
        delayBetween([hubGet("/set_alarm.cgi?http=1&http_url=$callbackURL&"), poll()], delayInterval())
    }
}

def deRegisterMotionCallback()
{
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This camera doesn't support deregistering callback URL, this should not be called"
    } else {
		log.debug "DeRegistering motion detection callback"
        delayBetween([hubGet("/set_alarm.cgi?http=0&"), poll()], delayInterval())
    }
}

def motionCallbackNotify()
{
    log.info("Callback Notify: Motion Alarm Alert!!")
    sendEvent(name: "alarmStatus", value: "alarm")
    sendEvent(name: "alarm", value: "both")
    sendEvent(name: "switch", value: "on")
    sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
    delayBetween(["delay 1000", poll()], 10000) // Polling will set the mode back to on or off (current mode), wait 10 seconds before turning off the alarm
}

def testTrace() {
	log.trace "*** Calling test trace ***"
}

private getPictureName() {
  def pictureUuid = java.util.UUID.randomUUID().toString().replaceAll('-', '')
  "image" + "_$pictureUuid" + ".jpg"
}

private getHostAddress(host) {
	return "${host}:${port}"
}

private String convertIPtoHex(ipAddress) {
	// Check for valid IPv4 address, ST doesn't support IPv6 yet
    if (!isIPAddress(ipAddress)) {
        log.error "Invalid IP Address $ipAddress, check your settings!"
        return
    }
    
	try {
        String hex = ipAddress.tokenize( '.' ).collect {  String.format('%02x', it.toInteger() ) }.join()  // thanks to @pstuart
        return hex
    } catch (Exception e) {
        log.error "Invalid IP Address $ipAddress, check your settings! Error: $e"
    }
}

private String convertPortToHex(port) {
	if (!port || (port == 0)) {
    	log.error "Invalid port $port, check your settings!"
    }
    
    try {
        String hexport = port.toString().format('%04x', port.toInteger() )   // thanks to @pstuart
        return hexport
    } catch (Exception e) {
        log.error "Invalid port $port, check your settings! Error: $e"
    }
}

private String getDetectionArea(area) {
	log.trace "User entered detection:$area"
    
    if (area?.trim()) {
    	// Remove any trailing or leading & if entered accidentally
        area = area.replaceAll("^&+", "") // Leading &
    	area = area.replaceAll("&+\$", "") // Trailing &
        return area
    } else {
        if (cameraModel == "Amba") { // Amba cameras have 3 detection areas with separate sensitivity levels
            return "x1=0&y1=0&width1=10000&height1=10000&sensitivity1=${getMotionLevel(motionLevel)}&valid1=1" // Default is full frame detection at specified sensitivity using a single area, areas 2 and 3 are disabled by default
        } else {
            return "area0=1023&area1=1023&area2=1023&area3=1023&area4=1023&area5=1023&area6=1023&area7=1023&area8=1023&area9=1023" // Default is full frame detection
        }
    }
}

private String getMotionLevel(motion) {
	log.trace "Motion detection level requested is $motion"

	String retVal = ""
    
    switch (motion) {
    	case "Lowest":
        	if (hdcamera)
        		retVal = "4"
        	else
                retVal = "9"
            break
            
    	case "Lower":
        	if (hdcamera)
        		retVal = "3"
        	else
                retVal = "7"
            break
            
    	case "Low":
        	if (hdcamera)
        		retVal = "0"
        	else
                retVal = "5"
            break
            
    	case "Medium":
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
            
    	case "High":
        	if (hdcamera)
        		retVal = "2"
        	else
                retVal = "0"
            break
            
		default:
        	log.warn "Invalid motion level $motion, check your settings, reverting to default"
            
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
    }
    
    log.trace("Motion detection value is $retVal")
    
    return retVal
}

private String getSoundLevel(sound) {
	log.trace "Sound detection level requested is $sound"

	String retVal = ""
    
    // For SD cameras the range is 0-9, 0 is the highest sensitivity
    // For HD cameras the range is 0-2, 0=low 1=middle 2=high sensitivity
    // For Ambarella cameras the range is 0-4, 4 - Lowest, 3 - Lower, 0 - Low, 1 - Medium, 2 - High
    switch (sound) {
    	case "Lowest":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "4"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "9"
            }
            break
            
    	case "Lower":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "3"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "7"
            }
            break
            
    	case "Low":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "0"
                } else {
                    retVal = "1"
                }
            } else {
                retVal = "5"
            }
            break
            
    	case "Medium":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "1"
                } else {
                    retVal = "1"
                }
            } else {
                retVal = "3"
            }
            break
            
    	case "High":
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "2"
                } else {
                    retVal = "2"
                }
            } else {
                retVal = "0"
            }
            break
            
		default:
        	log.warn "Invalid sound detection level $sound, check your settings, reverting to default"
            
        	if (hdcamera) {
                if (cameraModel == "Amba") {
                    retVal = "4"
                } else {
                    retVal = "0"
                }
            } else {
                retVal = "9"
            }
            break
    }
    
    log.trace("Sound detection value is $retVal")
    
    return retVal
}

private String getReArmInterval(interval) {
	log.trace("Trigger/ReArm internal is $interval")

	String retVal = ""
    
    switch (interval) {
    	case "5s":
        	retVal = "0"
            break
            
    	case "6s":
        	retVal = "1"
            break
            
    	case "7s":
        	retVal = "2"
            break
            
    	case "8s":
        	retVal = "3"
            break
            
    	case "9s":
        	retVal = "4"
            break
            
    	case "10s":
        	retVal = "5"
            break
            
    	case "11s":
        	retVal = "6"
            break
            
    	case "12s":
        	retVal = "7"
            break
            
    	case "13s":
        	retVal = "8"
            break
            
    	case "14s":
        	retVal = "9"
            break
            
    	case "15s":
        	retVal = "10"
            break
            
		default:
        	log.warn "Invalid trigger interval $interval, check your settings, reverting to default 10"
            
        	retVal = "10"
            break
    }

	log.trace("Snap interval value is $retVal")
    
    return retVal
}

private String getMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private String getAmbaMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    if (uploadCloud) {
    	ret |= (0x20 | 0x40) // Enabling uploading photo and recording to cloud
	    log.trace "Enabled uploading photo and recording to cloud, $ret"
    }
    
    if (pushFoscamPhoneApp) {
    	ret |= 0x80 // Enabling pushing message to native foscam app
	    log.trace "Enabled push message to native foscam phone app, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private boolean isIPAddress(String ipAddress)
{
    try
    {
         String[] parts = ipAddress.split("\\.")
         if (parts.length != 4) {
         	return false
         }
         for (int i = 0; i < 4; ++i)
         {
             int p = Integer.parseInt(parts[i])
             if (p > 255 || p < 0) {
             	return false
             }
         }
         return true
    } catch (Exception e)
    {
        return false
    }
}

private String convertHostnameToIPAddress(hostname) {
    def params = [
        uri: "http://dns.google.com/resolve?name=" + hostname,
        contentType: 'application/json'
    ]

    def retVal = null

    try {
        retVal = httpGet(params) { response ->
            log.trace "Request was successful, data=$response.data, status=$response.status"
            //log.trace "Result Status : ${response.data?.Status}"
            if (response.data?.Status == 0) { // Success
                for (answer in response.data?.Answer) { // Loop through results looking for the first IP address returned otherwise it's redirects
                    //log.trace "Processing response: ${answer}"
                    if (isIPAddress(answer?.data)) {
                        log.trace "Hostname ${answer?.name} has IP Address ${answer?.data}"
                        return answer?.data // We're done here (if there are more ignore it, we'll use the first IP address returned)
                    } else {
                        log.trace "Hostname ${answer?.name} redirected to ${answer?.data}"
                    }
                }
            } else {
                log.warn "DNS unable to resolve hostname ${response.data?.Question[0]?.name}, Error: ${response.data?.Comment}"
            }
        }
    } catch (Exception e) {
        log.warn("Unable to convert hostname to IP Address, Error: $e")
    }

    //log.trace "Returning IP $retVal for Hostname $hostname"
    return retVal
}

// Check if an ipAddress is a public ip address
private boolean isPublicIPAddress(String ipAddress) {
    try {
    	// Check for private IP Addresses
        // 0.255.255.255  (0/8 prefix) (all local)
        // 127.255.255.255  (127/8 prefix) (loopback)
        // 10.255.255.255  (10/8 prefix)
        // 172.31.255.255  (172.16/12 prefix)
        // 192.168.255.255 (192.168/16 prefix)
        // 169.254.255.255 (169.254/16 prefix) (link local)
        // Between 224.0.0.1 and 239.255.255.255 (multicast addresses)
    	if (ipAddress.find(/(^0\.)|(^127\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)|(^22[4-9]\.)|(^23[0-9]\.)/)) {
            log.trace "IPAddress $ipAddress is a private IP Address"
            return false
        } else {
            log.trace "IPAddress $ipAddress is a public IP Address"
            return true
        }
    } catch (Exception e) {
    	log.error "Invalid IPAddress $ipAddress"
        return false
    }
}

// Rate Limit to 10 Transactions per 60 seconds
private rateLimitExceeded(def x = "", def reset = false) {
    def retVal = false
    def rate = 10 // unit: transactions
    def per  = 60 * 1000 // unit: milliseconds
    
    // Changes to State variables are not committed until the function exist, hence we can't write and read back in the same function
    def allowance = state."allowance${x}"
    def last_check = state."last_check${x}"
    
    if (reset || !allowance) {
        allowance = rate // unit: transactions
        log.trace "Initializing Allowance $x: ${allowance}"
        if (reset) {
            return false
        }
    }
    if (reset || !last_check) {
        last_check = now() // Unit: milliseconds
        log.trace "Initializing Last Check $x: ${new Date(last_check)}"
        if (reset) {
            return retVal
        }
    }

    def current = now() // Unit: milliseconds
    def time_passed = current - last_check // Unit: milliseconds
    log.trace "Passed $x: ${time_passed/1000} seconds"
    last_check = current
    allowance = (allowance + (time_passed * (rate / per))) as BigDecimal // Patch as ST doesn't support float yet
    if (allowance > rate) {
        allowance = rate // throttle
    }
    if (allowance < 1) {
        retVal = true // discard transaction
        // Disable the next line if you don't want to penalize repeat offenders and allow it to reset after the duration (per)
        allowance = allowance - 1 // Continue to deplete the count to block continuous offenders
    } else {
        retVal = false // continue with transactions
        allowance = allowance - 1
    }
    
    log.trace "Allowance $x: ${allowance}, Last Check: ${new Date(last_check)}"
    
    state."allowance${x}" = allowance // finally update it
    state."last_check${x}" = last_check // finally update it
    
    return retVal
}

// THIS IS THE END OF THE FILE